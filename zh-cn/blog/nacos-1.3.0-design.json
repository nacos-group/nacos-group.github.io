{
  "filename": "nacos-1.3.0-design.md",
  "__html": "<h1>Nacos 1.3.0 特性以及功能使用文档</h1>\n<p><a name=\"0YIG0\"></a></p>\n<h2>概述</h2>\n<p>本次1.3.0的改动程度很大，涉及两大模块的修改以及新增一个核心模块</p>\n<ol>\n<li>nacos-core模块修改\n<ol>\n<li>nacos集群节点成员寻址模式的统一管理</li>\n<li>nacos内部事件机制</li>\n<li>nacos一致性协议层</li>\n</ol>\n</li>\n<li>nacos-config模块修改\n<ol>\n<li>新增内嵌分布式数据存储组件</li>\n<li>内嵌存储与外置存储细分</li>\n<li>内嵌存储简单运维</li>\n</ol>\n</li>\n<li>nacos-consistency模块新增\n<ol>\n<li>对于AP协议以及CP协议的统一抽象</li>\n</ol>\n</li>\n</ol>\n<br />\n<p><a name=\"rnkDY\"></a></p>\n<h2>系统参数变化</h2>\n<p><a name=\"1Gmg9\"></a></p>\n<h3>新增</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>core模块</strong></th>\n<th>nacos.watch-file.max-dirs</th>\n<th>JVM参数</th>\n<th>最大可监听目录数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n<td>nacos.core.notify.ring-buffer-size</td>\n<td>JVM参数</td>\n<td>快速通知队列的最大长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td>nacos.core.notify.share-buffer-size</td>\n<td>JVM参数</td>\n<td>慢速通知队列的最大长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td>nacos.core.member.fail-access-cnt</td>\n<td>JVM参数、application.properties配置</td>\n<td>集群成员节点最大失败访问次数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td>nacos.core.address-server.retry</td>\n<td>JVM参数、application.properties配置</td>\n<td>地址服务器寻址模式，首次启动请求重试次数</td>\n</tr>\n</tbody>\n</table>\n<br />\n<p><a name=\"kxo8O\"></a></p>\n<h2>Nacos的未来整体逻辑架构及其组件</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/333972/1587129046320-5a286f38-8db4-4e76-9b42-8bd859f51a60.png#align=left&amp;display=inline&amp;height=1184&amp;margin=%5Bobject%20Object%5D&amp;name=1561217775318-6e408805-18bb-4242-b4e9-83c5b929b469.png&amp;originHeight=1184&amp;originWidth=1608&amp;size=279074&amp;status=done&amp;style=none&amp;width=1608\" alt=\"1561217775318-6e408805-18bb-4242-b4e9-83c5b929b469.png\"></p>\n<p><a name=\"Hyc6u\"></a></p>\n<h2>Nacos集群成员节点寻址模式</h2>\n<p><br />在1.3.0之前，nacos的naming模块以及config模块存在各自的集群成员节点列表管理任务。为了统一nacos集群下成员列表的寻址模式，将集群节点管理的实现从naming模块以及config模块剥离出来，统一下沉到了core模块的寻址模，同时新增命令行参数 **-Dnacos.member.list **进行设置nacos集群节点列表，该参数可以看作是cluster.conf文件的一个替代。目前nacos的寻址模式类别如下</p>\n<ol>\n<li>单机模式下：StandaloneMemberLookup</li>\n<li>集群模式\n<ol>\n<li>cluster.conf文件存在：FileConfigMemberLookup</li>\n<li>cluster.conf文件不存在或者 -Dnacos.member.list没有设置：AddressServerMemberLookup</li>\n</ol>\n</li>\n</ol>\n<p>如果说想指定某一种寻址模式，则设置此参数：<strong>nacos.core.member.lookup.type=[file,address-server]</strong></p>\n<p>逻辑图如下\n<img src=\"https://cdn.nlark.com/yuque/__puml/e209a677aa8b5ffce23589e987ee5129.svg#lake_card_v2=eyJjb2RlIjoiQHN0YXJ0dW1sXG5cbigqKSAtLT4gXCJMb29rdXBGYWN0b3J5LmluaXQoKVwiXG5cbmlmIFwic3RhbmRhbG9uZSBtb2RlXCIgdGhlblxuICAtLT5bdHJ1ZV0gXCJyZXR1cm4gU3RhbmRhbG9uZU1lbWJlckxvb2t1cFwiXG4gIC0tPiBMb29rdXAucnVuKClcbmVsc2VcbiBpZiBcImNsdXN0ZXIuY29uZiBleGlzdHNcIiB0aGVuXG4gICAgLS0-W3RydWVdIFwicmV0dXJuIEZpbGVDb25maWdNZW1iZXJMb29rdXBcIlxuICAgIC0tPiBMb29rdXAucnVuKClcbiBlbHNlXG4gICAgLT5bZmFsc2VdIFwicmV0dXJuIEFkZHJlc3NTZXJ2ZXJNZW1iZXJMb29rdXBcIlxuICAgIC0tPiBMb29rdXAucnVuKClcbiBlbmRpZlxuZW5kaWZcblxuLS0-ICgqKVxuXG5AZW5kdW1sIiwidHlwZSI6InB1bWwiLCJpZCI6IlplWGtkIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fcHVtbC9lMjA5YTY3N2FhOGI1ZmZjZTIzNTg5ZTk4N2VlNTEyOS5zdmciLCJjYXJkIjoiZGlhZ3JhbSJ9\" alt=\"\"></p>\n<p><a name=\"wqkMp\"></a></p>\n<h3>寻址模式详细</h3>\n<p>接下来介绍除了单机模式下的寻址模式的其他两种寻址模式<br /></p>\n<p><a name=\"egl3H\"></a></p>\n<h4>FileConfigMemberLookup</h4>\n<p>该寻址模式是基于cluster.conf文件进行管理的，每个节点会读取各自{nacos.home}/conf下的cluster.conf文件内的成员节点列表，然后组成一个集群。并且在首次读取完{nacos.home}/conf下的cluster.conf文件后，会自动向操作系统的_<strong>inotify</strong>_机制注册一个目录监听器，监听{nacos.home}/conf目录下的所有文件变动（注意，这里只会监听文件，对于子目录下的文件变动无法监听）<br />当需要进行集群节点扩缩容时，需要手动去修改每个节点各自{nacos.home}/conf下的cluster.conf的成员节点列表内容。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> FileWatcher watcher = <span class=\"hljs-keyword\">new</span> FileWatcher() {\n\t\t<span class=\"hljs-meta\">@Override</span>\n\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onChange</span><span class=\"hljs-params\">(FileChangeEvent event)</span> </span>{\n\t\t\treadClusterConfFromDisk();\n\t\t}\n\n\t\t<span class=\"hljs-meta\">@Override</span>\n\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">interest</span><span class=\"hljs-params\">(String context)</span> </span>{\n\t\t\t<span class=\"hljs-keyword\">return</span> StringUtils.contains(context, <span class=\"hljs-string\">\"cluster.conf\"</span>);\n\t\t}\n};\n\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> NacosException </span>{\n\treadClusterConfFromDisk();\n\n\t<span class=\"hljs-keyword\">if</span> (memberManager.getServerList().isEmpty()) {\n\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> NacosException(NacosException.SERVER_ERROR,\n\t\t\t\t\t<span class=\"hljs-string\">\"Failed to initialize the member node, is empty\"</span>);\n\t}\n\n\t<span class=\"hljs-comment\">// Use the inotify mechanism to monitor file changes and automatically</span>\n\t<span class=\"hljs-comment\">// trigger the reading of cluster.conf</span>\n\t<span class=\"hljs-keyword\">try</span> {\n\t\tWatchFileCenter.registerWatcher(ApplicationUtils.getConfFilePath(), watcher);\n\t}\n\t<span class=\"hljs-keyword\">catch</span> (Throwable e) {\n\t\tLoggers.CLUSTER.error(<span class=\"hljs-string\">\"An exception occurred in the launch file monitor : {}\"</span>, e);\n\t}\n}\n</code></pre>\n<p>首次启动时直接读取cluster.conf文件内的节点列表信息，然后向WatchFileCenter注册一个目录监听器，当cluster.conf文件发生变动时自动触发_<strong>readClusterConfFromDisk()</strong>_重新读取cluster.conf文件<br /><img src=\"https://cdn.nlark.com/yuque/0/2020/png/333972/1591014354207-49c1e934-2aa5-465a-8a2b-0b09902814f8.png#align=left&amp;display=inline&amp;height=531&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=531&amp;originWidth=1169&amp;size=105696&amp;status=done&amp;style=none&amp;width=1169\" alt=\"image.png\">\n<a name=\"yFTCl\"></a></p>\n<h4>AddressServerMemberLookup</h4>\n<p>该寻址模式是基于一个额外的web服务器来管理cluster.conf，每个节点定期向该web服务器请求cluster.conf的文件内容，然后实现集群节点间的寻址，以及扩缩容。<br />当需要进行集群扩缩容时，只需要修改cluster.conf文件即可，然后每个节点向地址服务器请求时会自动的得到最新的cluster.conf文件内容。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> NacosException </span>{\n\t<span class=\"hljs-keyword\">if</span> (start.compareAndSet(<span class=\"hljs-keyword\">false</span>, <span class=\"hljs-keyword\">true</span>)) {\n\t\t<span class=\"hljs-keyword\">this</span>.maxFailCount = Integer.parseInt(ApplicationUtils.getProperty(<span class=\"hljs-string\">\"maxHealthCheckFailCount\"</span>, <span class=\"hljs-string\">\"12\"</span>));\n\t\tinitAddressSys();\n\t\trun();\n\t}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initAddressSys</span><span class=\"hljs-params\">()</span> </span>{\n\tString envDomainName = System.getenv(<span class=\"hljs-string\">\"address_server_domain\"</span>);\n\t<span class=\"hljs-keyword\">if</span> (StringUtils.isBlank(envDomainName)) {\n\t\tdomainName = System.getProperty(<span class=\"hljs-string\">\"address.server.domain\"</span>, <span class=\"hljs-string\">\"jmenv.tbsite.net\"</span>);\n\t} <span class=\"hljs-keyword\">else</span> {\n\t\tdomainName = envDomainName;\n\t}\n\tString envAddressPort = System.getenv(<span class=\"hljs-string\">\"address_server_port\"</span>);\n\t<span class=\"hljs-keyword\">if</span> (StringUtils.isBlank(envAddressPort)) {\n\t\taddressPort = System.getProperty(<span class=\"hljs-string\">\"address.server.port\"</span>, <span class=\"hljs-string\">\"8080\"</span>);\n\t} <span class=\"hljs-keyword\">else</span> {\n\t\taddressPort = envAddressPort;\n\t}\n\taddressUrl = System.getProperty(<span class=\"hljs-string\">\"address.server.url\"</span>,\n\t\t\t\tApplicationUtils.getContextPath() + <span class=\"hljs-string\">\"/\"</span> + <span class=\"hljs-string\">\"serverlist\"</span>);\n\taddressServerUrl = <span class=\"hljs-string\">\"http://\"</span> + domainName + <span class=\"hljs-string\">\":\"</span> + addressPort + addressUrl;\n\tenvIdUrl = <span class=\"hljs-string\">\"http://\"</span> + domainName + <span class=\"hljs-string\">\":\"</span> + addressPort + <span class=\"hljs-string\">\"/env\"</span>;\n\n\tLoggers.CORE.info(<span class=\"hljs-string\">\"ServerListService address-server port:\"</span> + addressPort);\n\tLoggers.CORE.info(<span class=\"hljs-string\">\"ADDRESS_SERVER_URL:\"</span> + addressServerUrl);\n}\n\n<span class=\"hljs-meta\">@SuppressWarnings</span>(<span class=\"hljs-string\">\"PMD.UndefineMagicConstantRule\"</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> NacosException </span>{\n\t<span class=\"hljs-comment\">// With the address server, you need to perform a synchronous member node pull at startup</span>\n\t<span class=\"hljs-comment\">// Repeat three times, successfully jump out</span>\n\t<span class=\"hljs-keyword\">boolean</span> success = <span class=\"hljs-keyword\">false</span>;\n\tThrowable ex = <span class=\"hljs-keyword\">null</span>;\n\t<span class=\"hljs-keyword\">int</span> maxRetry = ApplicationUtils.getProperty(<span class=\"hljs-string\">\"nacos.core.address-server.retry\"</span>, Integer<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, 5)</span>;\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; maxRetry; i ++) {\n\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\tsyncFromAddressUrl();\n\t\t\tsuccess = <span class=\"hljs-keyword\">true</span>;\n\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t} <span class=\"hljs-keyword\">catch</span> (Throwable e) {\n\t\t\tex = e;\n\t\t\tLoggers.CLUSTER.error(<span class=\"hljs-string\">\"[serverlist] exception, error : {}\"</span>, ExceptionUtil.getAllExceptionMsg(ex));\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">if</span> (!success) {\n\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> NacosException(NacosException.SERVER_ERROR, ex);\n\t}\n\n\tGlobalExecutor.scheduleByCommon(<span class=\"hljs-keyword\">new</span> AddressServerSyncTask(), <span class=\"hljs-number\">5_000L</span>);\n}\n</code></pre>\n<p>在初始化时，会主动去向地址服务器同步当前的集群成员列表信息，如果失败则进行重试，其最大重试次数可通过设置_<strong>nacos.core.address-server.retry</strong>_来控制，默认是5次，然后成功之后，将创建定时任务去向地址服务器同步集群成员节点信息<br /><img src=\"https://cdn.nlark.com/yuque/0/2020/png/333972/1591014362972-004f5338-af0d-4d0d-b769-4f3d5118c08a.png#align=left&amp;display=inline&amp;height=846&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=846&amp;originWidth=1149&amp;size=188886&amp;status=done&amp;style=none&amp;width=1149\" alt=\"image.png\">\n<a name=\"sgOTI\"></a></p>\n<h3>节点管理和寻址模式如何结合的</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/333972/1591014400580-39b83aa0-c548-4241-a49e-0d72abda2a95.png#align=left&amp;display=inline&amp;height=715&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=715&amp;originWidth=1189&amp;size=131826&amp;status=done&amp;style=none&amp;width=1189\" alt=\"image.png\"><br />MemberLookup在启动之后，会根据不同的寻址模式，执行寻址任务，将收集到集群节点列表信息，调用memberChange，触发集群节点变动，然后发布节点变更事件\n<a name=\"idHpC\"></a></p>\n<h2>Nacos一致性协议协议层抽象</h2>\n<p>从nacos的未来的整体架构图可以看出，一致性协议层将是作为nacos的最为核心的模块，将服务于构建在core模块之上的各个功能模块，或者服务与core模块本身。而一致性协议因为分区容错性的存在，需要在可用性与一致性之间做选择，因此就存在两大类一致性：最终一致性和强一致性。在nacos中，这两类一致性协议都是可能用到的，比如naming模块，对于服务实例的数据管理分别用到了AP以及CP，而对于config模块，将会涉及使用CP。同时还有如下几个功能需求点</p>\n<ol>\n<li>目前持久化服务使用用了变种版本的raft，并且业务和raft协议耦合，因此需要抽离解耦，同时是选择一个标准的Java版Raft实现</li>\n<li>对于中小用户，配置基本其实不会超级多，独立一个mysql，相对重一些，需要一个轻量化的存储方案，并且支持2.0不依赖mysql和3.0依赖mysql可配置能力</li>\n<li>由于CP或者AP，其存在多种实现，如何对一致性协议层做一次很好的抽象，以便将来可以快速的实现底层一致性协议具体实现的替换，比如Raft协议，目前nacos的选型是JRaft，不排除将来nacos会自己实现一个标准raft协议或者实现Paxos协议</li>\n<li>由于Nacos存在多个独立工作的功能模块，每个功能模块之间不能出现影响，比如A模块处理请求过慢或者出现异常时，不能影响B模块的正常工作，即每个功能模块在使用一致性协议时，如何将每个模块的数据处理进行隔离？</li>\n</ol>\n<p>根据一致协议以及上述功能需求点，本次做了一个抽象的一致协议层以及相关的接口\n<a name=\"3w8xM\"></a></p>\n<h3>一致协议抽象</h3>\n<p><a name=\"p7zRo\"></a></p>\n<h4>ConsistencyProtocol</h4>\n<p>所谓一致性，即多个副本之间是否能够保持一致性的特性，而副本的本质就是数据，对数据的操作，不是获取就是修改。同时，一致协议其实是针对分布式情况的，而这必然涉及多个节点，因此，需要有相应的接口能够调整一致性协议的协同工作节点。如果我们要观察一致性协议运行的情况，该怎么办？比如Raft协议，我们希望得知当前集群中的Leader是谁，任期的情况，当前集群中的成员节点有谁？因此，还需要提供一个一致性协议元数据获取。<br />综上所述，ConsistencyProtcol的大致设计可以出来了</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">ConsistencyProtocol</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Config</span>, <span class=\"hljs-title\">P</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">LogProcessor</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">CommandOperations</span> </span>{\n\n    <span class=\"hljs-comment\">/**\n     * Consistency protocol initialization: perform initialization operations based on the incoming Config\n     * 一致性协议初始化，根据 Config 实现类\n     *\n     * <span class=\"hljs-doctag\">@param</span> config {<span class=\"hljs-doctag\">@link</span> Config}\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(T config)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * Add a log handler\n     *\n     * <span class=\"hljs-doctag\">@param</span> processors {<span class=\"hljs-doctag\">@link</span> LogProcessor}\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addLogProcessors</span><span class=\"hljs-params\">(Collection&lt;P&gt; processors)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * Copy of metadata information for this consensus protocol\n     * 该一致性协议的元数据信息\n     *\n     * <span class=\"hljs-doctag\">@return</span> metaData {<span class=\"hljs-doctag\">@link</span> ProtocolMetaData}\n     */</span>\n    <span class=\"hljs-function\">ProtocolMetaData <span class=\"hljs-title\">protocolMetaData</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * Obtain data according to the request\n     *\n     * <span class=\"hljs-doctag\">@param</span> request request\n     * <span class=\"hljs-doctag\">@return</span> data {<span class=\"hljs-doctag\">@link</span> Response}\n     * <span class=\"hljs-doctag\">@throws</span> Exception\n     */</span>\n    <span class=\"hljs-function\">Response <span class=\"hljs-title\">getData</span><span class=\"hljs-params\">(GetRequest request)</span> <span class=\"hljs-keyword\">throws</span> Exception</span>;\n\n    <span class=\"hljs-comment\">/**\n     * Get data asynchronously\n     *\n     * <span class=\"hljs-doctag\">@param</span> request request\n     * <span class=\"hljs-doctag\">@return</span> data {<span class=\"hljs-doctag\">@link</span> CompletableFuture&lt;Response&gt;}\n     */</span>\n    <span class=\"hljs-function\">CompletableFuture&lt;Response&gt; <span class=\"hljs-title\">aGetData</span><span class=\"hljs-params\">(GetRequest request)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * Data operation, returning submission results synchronously\n     * 同步数据提交，在 Datum 中已携带相应的数据操作信息\n     *\n     * <span class=\"hljs-doctag\">@param</span> data {<span class=\"hljs-doctag\">@link</span> Log}\n     * <span class=\"hljs-doctag\">@return</span> submit operation result {<span class=\"hljs-doctag\">@link</span> Response}\n     * <span class=\"hljs-doctag\">@throws</span> Exception\n     */</span>\n    <span class=\"hljs-function\">Response <span class=\"hljs-title\">submit</span><span class=\"hljs-params\">(Log data)</span> <span class=\"hljs-keyword\">throws</span> Exception</span>;\n\n    <span class=\"hljs-comment\">/**\n     * Data submission operation, returning submission results asynchronously\n     * 异步数据提交，在 Datum 中已携带相应的数据操作信息，返回一个Future，自行操作，提交发生的异常会在CompleteFuture中\n     *\n     * <span class=\"hljs-doctag\">@param</span> data {<span class=\"hljs-doctag\">@link</span> Log}\n     * <span class=\"hljs-doctag\">@return</span> {<span class=\"hljs-doctag\">@link</span> CompletableFuture&lt;Response&gt;} submit result\n     * <span class=\"hljs-doctag\">@throws</span> Exception when submit throw Exception\n     */</span>\n    <span class=\"hljs-function\">CompletableFuture&lt;Response&gt; <span class=\"hljs-title\">submitAsync</span><span class=\"hljs-params\">(Log data)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * New member list\n     * 新的成员节点列表，一致性协议自行处理相应的成员节点是加入还是离开\n     *\n     * <span class=\"hljs-doctag\">@param</span> addresses [ip:port, ip:port, ...]\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">memberChange</span><span class=\"hljs-params\">(Set&lt;String&gt; addresses)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * Consistency agreement service shut down\n     * 一致性协议服务关闭\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">shutdown</span><span class=\"hljs-params\">()</span></span>;\n\n}\n</code></pre>\n<p>而针对CP协议，由于存在Leader的概念，因此需要提供一个方法用于获取CP协议当前的Leader是谁</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">CPProtocol</span>&lt;<span class=\"hljs-title\">C</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Config</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ConsistencyProtocol</span>&lt;<span class=\"hljs-title\">C</span>&gt; </span>{\n\n\t<span class=\"hljs-comment\">/**\n\t * Returns whether this node is a leader node\n\t *\n\t * <span class=\"hljs-doctag\">@param</span> group business module info\n\t * <span class=\"hljs-doctag\">@return</span> is leader\n\t * <span class=\"hljs-doctag\">@throws</span> Exception\n\t */</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isLeader</span><span class=\"hljs-params\">(String group)</span> <span class=\"hljs-keyword\">throws</span> Exception</span>;\n\n}\n</code></pre>\n<p><a name=\"oJFpB\"></a></p>\n<h4>数据操作请求提交对象：Log、GetRequest</h4>\n<p>上面说到，一致性协议其实是对于数据操作而言的，数据操作基本分为两大类：数据查询以及数据修改，同时还要满足不同功能模块之间的数据进行隔离。因此这里针对数据修改操作以及数据查询操作分别阐述。</p>\n<ol>\n<li>数据修改\n<ol>\n<li>数据修改操作，一定要知道本次请求是属于哪一个功能模块的</li>\n<li>数据修改操作，首先一定要知道这个数据的修改操作具体是哪一种修改操作，方便功能模块针对真正的数据修改操作进行相应的逻辑操作</li>\n<li>数据修改操作，一定要知道修改的数据是什么，即请求体，为了使得一致性协议层更为通用，这里对于请求体的数据结构，选择了byte[]数组</li>\n<li>数据的类型，由于我们将真正的数据序列化为了byte[]数组，为了能够正常序列化，我们可能还需要记录这个数据的类型是什么</li>\n<li>本次请求的信息摘要或者标识信息</li>\n<li>本次请求的额外信息，用于将来扩展需要传输的数据</li>\n</ol>\n</li>\n</ol>\n<p>综上，可以得出Log对象的设计如下</p>\n<pre><code class=\"language-protobuf\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">message</span> <span class=\"hljs-title\">Log</span> </span>{\n\t<span class=\"hljs-comment\">// 功能模块分组信息</span>\n    <span class=\"hljs-built_in\">string</span> <span class=\"hljs-keyword\">group</span> = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-comment\">// 摘要或者标识</span>\n    <span class=\"hljs-built_in\">string</span> key = <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-comment\">// 具体请求数据</span>\n    <span class=\"hljs-built_in\">bytes</span> data = <span class=\"hljs-number\">3</span>;\n    <span class=\"hljs-comment\">// 数据类型</span>\n    <span class=\"hljs-built_in\">string</span> type = <span class=\"hljs-number\">4</span>;\n    <span class=\"hljs-comment\">// 更为具体的数据操作</span>\n    <span class=\"hljs-built_in\">string</span> operation = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-comment\">// 额外信息</span>\n    map&lt;<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-built_in\">string</span>&gt; extendInfo = <span class=\"hljs-number\">6</span>;\n}\n</code></pre>\n<ol start=\"2\">\n<li>数据查询\n<ol>\n<li>数据查询操作，一定要知道本次请求是由哪一个功能模块发起的</li>\n<li>数据查询的条件是什么，为了兼容各种存储结构的数据查询操作，这里用byte[]进行存储</li>\n<li>本次请求的额外信息，用于将来扩展需要传输的数据</li>\n</ol>\n</li>\n</ol>\n<p>综上，可以得出GetRequest对象的设计如下</p>\n<pre><code class=\"language-protobuf\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">message</span> <span class=\"hljs-title\">GetRequest</span> </span>{\n\t<span class=\"hljs-comment\">// 功能模块分组信息</span>\n    <span class=\"hljs-built_in\">string</span> <span class=\"hljs-keyword\">group</span> = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-comment\">// 具体请求数据</span>\n    <span class=\"hljs-built_in\">bytes</span> data = <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-comment\">// 额外信息</span>\n    map&lt;<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-built_in\">string</span>&gt; extendInfo = <span class=\"hljs-number\">3</span>;\n}\n</code></pre>\n<p><a name=\"vBig4\"></a></p>\n<h4>功能模块使用一致性协议：LogProcessor</h4>\n<p>当数据操作通过一致性协议进行submit之后，每个节点需要去处理这个Log或者GetRequest对象，因此，我们需要抽象出一个Log、GetRequest对象的Processor，不同的功能模块通过实现该处理器，ConsistencyProtocol内部会根据Log、GetRequest的group属性，将Log、GetRequest对象路由到具体的Processor，当然，Processor也需要表明自己是属于哪一个功能模块的。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LogProcessor</span> </span>{\n\n    <span class=\"hljs-comment\">/**\n     * get data by key\n     *\n     * <span class=\"hljs-doctag\">@param</span> request request {<span class=\"hljs-doctag\">@link</span> GetRequest}\n     * <span class=\"hljs-doctag\">@return</span> target type data\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> Response <span class=\"hljs-title\">onRequest</span><span class=\"hljs-params\">(GetRequest request)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * Process Submitted Log\n     *\n     * <span class=\"hljs-doctag\">@param</span> log {<span class=\"hljs-doctag\">@link</span> Log}\n     * <span class=\"hljs-doctag\">@return</span> {<span class=\"hljs-doctag\">@link</span> boolean}\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> Response <span class=\"hljs-title\">onApply</span><span class=\"hljs-params\">(Log log)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * Irremediable errors that need to trigger business price cuts\n     *\n     * <span class=\"hljs-doctag\">@param</span> error {<span class=\"hljs-doctag\">@link</span> Throwable}\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onError</span><span class=\"hljs-params\">(Throwable error)</span> </span>{\n    }\n\n    <span class=\"hljs-comment\">/**\n     * In order for the state machine that handles the transaction to be able to route\n     * the Log to the correct LogProcessor, the LogProcessor needs to have an identity\n     * information\n     *\n     * <span class=\"hljs-doctag\">@return</span> Business unique identification name\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> String <span class=\"hljs-title\">group</span><span class=\"hljs-params\">()</span></span>;\n\n}\n</code></pre>\n<p>针对CP协议，比如Raft协议，存在快照的设计，因此我们需要针对CP协议单独扩展出一个方法</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LogProcessor4CP</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">LogProcessor</span> </span>{\n\n    <span class=\"hljs-comment\">/**\n     * Discovery snapshot handler\n     * It is up to LogProcessor to decide which SnapshotOperate should be loaded and saved by itself\n     *\n     * <span class=\"hljs-doctag\">@return</span> {<span class=\"hljs-doctag\">@link</span> List &lt;SnapshotOperate&gt;}\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> List&lt;SnapshotOperation&gt; <span class=\"hljs-title\">loadSnapshotOperate</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> Collections.emptyList();\n    }\n\n}\n</code></pre>\n<p><a name=\"zbsAE\"></a></p>\n<h4>综述</h4>\n<p>从上面这几点可以看出来，ConsistencyProtocol是对上层功能模块暴露出来的使用接口，每个ConsistencyProtocol后面有具体的一致性协议实现的Backend，由于Backend无法很好的兼容nacos现有的架构设计，因此额外设计的LogProcessor就是为了解决这个问题。<br /><img src=\"https://cdn.nlark.com/yuque/0/2020/png/333972/1591015048030-8a4bff4a-20ed-46dd-a7f7-98655b22946f.png#align=left&amp;display=inline&amp;height=591&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=591&amp;originWidth=886&amp;size=93327&amp;status=done&amp;style=none&amp;width=886\" alt=\"image.png\"><br />同时，由于在一致性协议层内部的Backend中需要实现对不同业务模块的数据进行隔离处理，而这个一块逻辑由请求对象和LogProcessor的group属性来实现<br /><img src=\"https://cdn.nlark.com/yuque/0/2020/png/333972/1591015155835-a897262e-8e57-409c-bf94-d57bf765c80b.png#align=left&amp;display=inline&amp;height=591&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=591&amp;originWidth=910&amp;size=118083&amp;status=done&amp;style=none&amp;width=910\" alt=\"image.png\">\n<a name=\"C1yU6\"></a></p>\n<h3>一致性协议层工作流程</h3>\n<p>我们可以通过一个时序图看看，一致性协议层的大致工作流程\n<img src=\"https://cdn.nlark.com/yuque/__puml/30b7e270e7aef8bb63136aaffbe5bfbf.svg#lake_card_v2=eyJjb2RlIjoiQHN0YXJ0dW1sXG5cbnBhcnRpY2lwYW50IFwiTWVtYmVyTWFuYWdlclwiIGFzIE5hY29zQ2x1c3RlclxucGFydGljaXBhbnQgXCJCdXNpbmVzc01vZHVsZVwiIGFzIEJpelxucGFydGljaXBhbnQgXCJDb25zaXN0ZW5jeVByb3RvY29sXCIgYXMgUHJvdG9jb2xcbnBhcnRpY2lwYW50IFwiQ0FQQmFja2VuZFwiIGFzIEJhY2tlbmRcbnBhcnRpY2lwYW50IFwiQ29uZmlnXCIgYXMgQ29uZmlnXG5wYXJ0aWNpcGFudCBcIkxvZ1Byb2Nlc3NvclwiIGFzIFByb2Nlc3NvclxucGFydGljaXBhbnQgXCJMb2dcIiBhcyBMb2dcblxuYWN0aXZhdGUgTmFjb3NDbHVzdGVyXG5OYWNvc0NsdXN0ZXIgLT4gTmFjb3NDbHVzdGVyOiBpbml0KCkg5Yid5aeL5YyWTmFjb3Ppm4bnvqRcblxuTmFjb3NDbHVzdGVyIC0-IENvbmZpZzog6I635Y-WQ29uZmln5a-56LGhXG5hY3RpdmF0ZSBDb25maWdcbkNvbmZpZyAtPiBDb25maWc6IOaUtumbhkxvZ1Byb2Nlc3NvcueahOS_oeaBr1xuQ29uZmlnIC0-IE5hY29zQ2x1c3RlclxuZGVhY3RpdmF0ZSBDb25maWdcblxuXG5OYWNvc0NsdXN0ZXIgLT4gUHJvdG9jb2w6IOiOt-WPluaJgOaciUNvbnNpc3RlbmN5UHJvdG9jb2zlrp7njrBcbmFjdGl2YXRlIFByb3RvY29sXG5cbk5hY29zQ2x1c3RlciAtPiBQcm90b2NvbDogaW5pdChDb25maWcpIOaWueazleaJp-ihjFxuXG5kZWFjdGl2YXRlIFByb3RvY29sXG5kZWFjdGl2YXRlIE5hY29zQ2x1c3RlclxuXG5cbkJpeiAtPiBMb2c6IOWIm-W7uuS4gOS4quS6i-WKoeWvueixoVxuYWN0aXZhdGUgQml6XG5hY3RpdmF0ZSBMb2dcblxuXG5Mb2cgLT4gTG9nOiDorr7nva5kYXRhXG5Mb2cgLT4gTG9nOiDorr7nva5rZXlcbkxvZyAtPiBMb2c6IOiuvue9rmNsYXNzTmFtZVxuTG9nIC0-IExvZzog6K6-572uZXh0ZW5kSW5mb1xuTG9nIC0-IEJpelxuZGVhY3RpdmF0ZSBMb2dcblxuQml6IC0-IFByb3RvY29sOiBzdWJtaXQoTG9nKSDosIPnlKjkuIDoh7TmgKfljY_orq7ov5vooYzkuovliqHmj5DkuqRcbmFjdGl2YXRlIFByb3RvY29sXG5cblByb3RvY29sIC0-IEJhY2tlbmQ6IOWGhemDqOS4gOiHtOaAp-WNj-iuruW3peS9nFxuYWN0aXZhdGUgQmFja2VuZFxuXG5CYWNrZW5kIC0-IFByb3RvY29sOiDov5Tlm57lt6XkvZzlpITnkIbnu5PmnpxcbmRlYWN0aXZhdGUgQmFja2VuZFxuXG5Qcm90b2NvbCAtPiBQcm9jZXNzb3I6IOWwhkxvZ-WIhuWPkeWIsOWvueW6lOeahFByb2Nlc3Nvcu-8jOiwg-eUqCBvbkFwcGx5IOaWueazlVxuYWN0aXZhdGUgUHJvdG9jb2xcbmRlYWN0aXZhdGUgUHJvdG9jb2xcblxuUHJvY2Vzc29yIC0-IEJpejog5LqL5Yqh5o-Q5Lqk57uT5p6cXG5cbmRlYWN0aXZhdGUgUHJvY2Vzc29yXG5kZWFjdGl2YXRlIEJpelxuXG5AZW5kdW1sIiwidHlwZSI6InB1bWwiLCJtYXJnaW4iOnRydWUsImlkIjoiNFZpMkwiLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19wdW1sLzMwYjdlMjcwZTdhZWY4YmI2MzEzNmFhZmZiZTViZmJmLnN2ZyIsImNhcmQiOiJkaWFncmFtIn0=\" alt=\"\"><a name=\"xtBNU\"></a></p>\n<h3>Nacos一致性协议层之CP协议的实现选择——JRaft</h3>\n<p>一致性协议层抽象好之后，剩下就是具体一致性协议实现的选择了，这里我们选择了蚂蚁金服开源的JRaft，那么我们如何将JRaft作为CP协议的一个Backend呢？下面的简单流程图描述了当JRaft作为CP协议的一个Backend时的初始化流程</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/**\n * A concrete implementation of CP protocol: JRaft\n *\n * &lt;pre&gt;\n *                                           ┌──────────────────────┐               \n *                                           │                      │               \n *            ┌──────────────────────┐       │                      ▼               \n *            │   ProtocolManager    │       │        ┌───────────────────────────┐ \n *            └──────────────────────┘       │        │for p in [LogProcessor4CP] │ \n *                        │                  │        └───────────────────────────┘ \n *                        ▼                  │                      │               \n *      ┌──────────────────────────────────┐ │                      ▼               \n *      │    discovery LogProcessor4CP     │ │             ┌─────────────────┐      \n *      └──────────────────────────────────┘ │             │  get p.group()  │      \n *                        │                  │             └─────────────────┘      \n *                        ▼                  │                      │               \n *                 ┌─────────────┐           │                      │               \n *                 │ RaftConfig  │           │                      ▼               \n *                 └─────────────┘           │      ┌──────────────────────────────┐\n *                        │                  │      │  create raft group service   │\n *                        ▼                  │      └──────────────────────────────┘\n *              ┌──────────────────┐         │                                      \n *              │  JRaftProtocol   │         │                                      \n *              └──────────────────┘         │                                      \n *                        │                  │                                      \n *                     init()                │                                      \n *                        │                  │                                      \n *                        ▼                  │                                      \n *               ┌─────────────────┐         │                                      \n *               │   JRaftServer   │         │                                      \n *               └─────────────────┘         │                                      \n *                        │                  │                                      \n *                        │                  │                                      \n *                        ▼                  │                                      \n *             ┌────────────────────┐        │                                      \n *             │JRaftServer.start() │        │                                      \n *             └────────────────────┘        │                                      \n *                        │                  │                                      \n *                        └──────────────────┘                                      \n * &lt;/pre&gt;\n * \n * <span class=\"hljs-doctag\">@author</span> &lt;a href=\"mailto:liaochuntao@live.com\"&gt;liaochuntao&lt;/a&gt;\n */</span>\n</code></pre>\n<p>JRaftProtocol是当JRaft作为CP协议的Backend时的一个ConsistencyProtocol的具体实现，其内部有一个JRaftServer成员属性，JRaftServer分装了JRaft的各种API操作，比如数据操作的提交，数据的查询，成员节点的变更，Leader节点的查询等等。</p>\n<p><em><strong>注意事项：JRaft运行期间产生的数据在${nacos.home}/data/protocol/raft文件目录下。不同的业务模块有不同的文件分组，如果当节点出现crash或者异常关闭时，清空该目录下的文件，重启节点即可</strong></em></p>\n<p>由于JRaft实现了raft group的概念，因此，完全可以利用raft group的设计，为每个功能模块单独创建一个raft group。这里给出部分代码，该代码体现了如何将LogProcessor嵌入到状态机中并为每个LogPrcessor创建一个Raft Group</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">createMultiRaftGroup</span><span class=\"hljs-params\">(Collection&lt;LogProcessor4CP&gt; processors)</span> </span>{\n\t<span class=\"hljs-comment\">// There is no reason why the LogProcessor cannot be processed because of the synchronization</span>\n\t<span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.isStarted) {\n\t\t<span class=\"hljs-keyword\">this</span>.processors.addAll(processors);\n\t\t<span class=\"hljs-keyword\">return</span>;\n\t}\n\n\t<span class=\"hljs-keyword\">final</span> String parentPath = Paths\n\t\t\t\t.get(ApplicationUtils.getNacosHome(), <span class=\"hljs-string\">\"data/protocol/raft\"</span>).toString();\n\n\t<span class=\"hljs-keyword\">for</span> (LogProcessor4CP processor : processors) {\n\t\t<span class=\"hljs-keyword\">final</span> String groupName = processor.group();\n\t\t<span class=\"hljs-keyword\">if</span> (multiRaftGroup.containsKey(groupName)) {\n\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> DuplicateRaftGroupException(groupName);\n\t\t}\n\n\t\t<span class=\"hljs-comment\">// Ensure that each Raft Group has its own configuration and NodeOptions</span>\n\t\tConfiguration configuration = conf.copy();\n\t\tNodeOptions copy = nodeOptions.copy();\n\t\tJRaftUtils.initDirectory(parentPath, groupName, copy);\n\n\t\t<span class=\"hljs-comment\">// Here, the LogProcessor is passed into StateMachine, and when the StateMachine</span>\n\t\t<span class=\"hljs-comment\">// triggers onApply, the onApply of the LogProcessor is actually called</span>\n\t\tNacosStateMachine machine = <span class=\"hljs-keyword\">new</span> NacosStateMachine(<span class=\"hljs-keyword\">this</span>, processor);\n\n\t\tcopy.setFsm(machine);\n\t\tcopy.setInitialConf(configuration);\n\n\t\t<span class=\"hljs-comment\">// Set snapshot interval, default 1800 seconds</span>\n\t\t<span class=\"hljs-keyword\">int</span> doSnapshotInterval = ConvertUtils.toInt(raftConfig\n\t\t\t\t\t\t\t.getVal(RaftSysConstants.RAFT_SNAPSHOT_INTERVAL_SECS),\n\t\t\t\t\tRaftSysConstants.DEFAULT_RAFT_SNAPSHOT_INTERVAL_SECS);\n\n\t\t<span class=\"hljs-comment\">// If the business module does not implement a snapshot processor, cancel the snapshot</span>\n\t\tdoSnapshotInterval = CollectionUtils\n\t\t\t\t\t.isEmpty(processor.loadSnapshotOperate()) ? <span class=\"hljs-number\">0</span> : doSnapshotInterval;\n\n\t\tcopy.setSnapshotIntervalSecs(doSnapshotInterval);\n\t\tLoggers.RAFT.info(<span class=\"hljs-string\">\"create raft group : {}\"</span>, groupName);\n\t\tRaftGroupService raftGroupService = <span class=\"hljs-keyword\">new</span> RaftGroupService(groupName,\n\t\t\t\t\tlocalPeerId, copy, rpcServer, <span class=\"hljs-keyword\">true</span>);\n\n\t\t<span class=\"hljs-comment\">// Because RpcServer has been started before, it is not allowed to start again here</span>\n\t\tNode node = raftGroupService.start(<span class=\"hljs-keyword\">false</span>);\n\t\tmachine.setNode(node);\n\t\tRouteTable.getInstance().updateConfiguration(groupName, configuration);\n\t\tRaftExecutor.executeByCommon(() -&gt; registerSelfToCluster(groupName, localPeerId, configuration));\n\n\t\t<span class=\"hljs-comment\">// Turn on the leader auto refresh for this group</span>\n\t\tRandom random = <span class=\"hljs-keyword\">new</span> Random();\n\t\t<span class=\"hljs-keyword\">long</span> period = nodeOptions.getElectionTimeoutMs() + random.nextInt(<span class=\"hljs-number\">5</span> * <span class=\"hljs-number\">1000</span>);\n\t\tRaftExecutor.scheduleRaftMemberRefreshJob(() -&gt; refreshRouteTable(groupName),\n\t\t\t\t\tnodeOptions.getElectionTimeoutMs(), period, TimeUnit.MILLISECONDS);\n\t\tmultiRaftGroup.put(groupName,\n\t\t\t\t\t<span class=\"hljs-keyword\">new</span> RaftGroupTuple(node, processor, raftGroupService, machine));\n\t}\n}\n</code></pre>\n<p><a name=\"4czvB\"></a></p>\n<h4>疑问解答：为什么要创建多个raft group<br /></h4>\n<p>或许有的人会有疑问，既然之前已经设计出了LogProcessor，完全可以利用一个Raft Group，在状态机appl时，根据Log的group属性进行路由到不同的LogProcessor即可，每个功能模块就创建一个raft group，不是会消耗大量的资源吗？<br />正如之前所说，我们希望独立工作的模块之间相互不存在影响，比如A模块处理Log因为存在Block操作可能使得apply的速度缓慢，亦或者可能中途发生异常，对于Raft协议来说，当日志apply失败时，状态机将不能够继续向前推进，因为如果继续向前推进的话，由于上一步的apply失败，后面的所有apply都可能失败，将会导致这个节点的数据与其他节点的数据永远不一致。如果说我们将所有独立工作的模块，对于数据操作的请求处理放在同一个raft group，即一个状态机中，就不可避免的会出现上述所说的问题，某个模块在apply日志发生不可控的因素时，会影响其他模块的正常工作。\n<a name=\"2GyRw\"></a></p>\n<h3>JRaft运维操作</h3>\n<p>为了使用者能够对JRaft进行相关简单的运维，比如Leader的切换，重置当前Raft集群成员，触发某个节点进行Snapshot操作等等，提供了一个简单的HTTP接口进行操作，并且该接口有一定的限制，即每次只会执行一条运维指令</p>\n<p>1、切换某一个Raft Group的Leader节点</p>\n<pre><code class=\"language-java\">POST /nacos/v1/core/ops/raft\n{\n    <span class=\"hljs-string\">\"groupId\"</span>: <span class=\"hljs-string\">\"xxx\"</span>,\n    <span class=\"hljs-string\">\"command\"</span>: <span class=\"hljs-string\">\"transferLeader\"</span>\n    <span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"ip:{raft_port} or ip:{raft_port},ip:{raft_port},ip:{raft_port}\"</span>\n}\n</code></pre>\n<p><a name=\"Fs7VE\"></a>\n2、重置某一个Raft Group的集群成员</p>\n<pre><code class=\"language-java\">POST /nacos/v1/core/ops/raft\n{\n    <span class=\"hljs-string\">\"groupId\"</span>: <span class=\"hljs-string\">\"xxx\"</span>,\n    <span class=\"hljs-string\">\"command\"</span>: <span class=\"hljs-string\">\"resetRaftCluster\"</span>,\n    <span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"ip:{raft_port},ip:{raft_port},ip:{raft_port},ip:{raft_port}\"</span>\n}\n</code></pre>\n<p>注意，该操作是一个高危操作，仅仅当Raft集群的 n/2 + 1节点crash之后无法满足过半投票的要求才可以使用该运维命令，用于快速让当前剩余的节点重组Raft集群，对外提供服务，但是这个操作很大程度会造成数据的丢失<br /></p>\n<p><a name=\"VfG5T\"></a>\n3、触发某一个Raft Group执行快照操作</p>\n<pre><code class=\"language-java\">POST /nacos/v1/core/ops/raft\n{\n    <span class=\"hljs-string\">\"groupId\"</span>: <span class=\"hljs-string\">\"xxx\"</span>,\n    <span class=\"hljs-string\">\"command\"</span>: <span class=\"hljs-string\">\"doSnapshot\"</span>,\n    <span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"ip:{raft_port}\"</span>\n}\n</code></pre>\n<p><a name=\"m9LfI\"></a>\n4、移除某一个Raft Group中的某一成员</p>\n<pre><code class=\"language-java\">POST /nacos/v1/core/ops/raft\n{\n    <span class=\"hljs-string\">\"groupId\"</span>: <span class=\"hljs-string\">\"xxx\"</span>,\n    <span class=\"hljs-string\">\"command\"</span>: <span class=\"hljs-string\">\"removePeer\"</span>,\n    <span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"ip:{raft_port}\"</span>\n}\n</code></pre>\n<p><a name=\"ev3MW\"></a>\n5、批量移除某一个Raft Group中的多个成员</p>\n<pre><code class=\"language-java\">POST /nacos/v1/core/ops/raft\n{\n    <span class=\"hljs-string\">\"groupId\"</span>: <span class=\"hljs-string\">\"xxx\"</span>,\n    <span class=\"hljs-string\">\"command\"</span>: <span class=\"hljs-string\">\"removePeers\"</span>,\n    <span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"ip:{raft_port},ip:{raft_port},ip:{raft_port},...\"</span>\n}\n</code></pre>\n<p><a name=\"GzMuP\"></a></p>\n<h3>JRaft协议相关配置参数</h3>\n<pre><code class=\"language-yaml\"><span class=\"hljs-comment\">### Sets the Raft cluster election timeout, default value is 5 second</span>\n<span class=\"hljs-string\">nacos.core.protocol.raft.data.election_timeout_ms=5000</span>\n<span class=\"hljs-comment\">### Sets the amount of time the Raft snapshot will execute periodically, default is 30 minute</span>\n<span class=\"hljs-string\">nacos.core.protocol.raft.data.snapshot_interval_secs=30</span>\n<span class=\"hljs-comment\">### Requested retries, default value is 1</span>\n<span class=\"hljs-string\">nacos.core.protocol.raft.data.request_failoverRetries=1</span>\n<span class=\"hljs-comment\">### raft internal worker threads</span>\n<span class=\"hljs-string\">nacos.core.protocol.raft.data.core_thread_num=8</span>\n<span class=\"hljs-comment\">### Number of threads required for raft business request processing</span>\n<span class=\"hljs-string\">nacos.core.protocol.raft.data.cli_service_thread_num=4</span>\n<span class=\"hljs-comment\">### raft linear read strategy, defaults to index</span>\n<span class=\"hljs-string\">nacos.core.protocol.raft.data.read_index_type=ReadOnlySafe</span>\n<span class=\"hljs-comment\">### rpc request timeout, default 5 seconds</span>\n<span class=\"hljs-string\">nacos.core.protocol.raft.data.rpc_request_timeout_ms=5000</span>\n</code></pre>\n<h4>线性读参数解析</h4>\n<ol>\n<li><strong>ReadOnlySafe</strong>\n<ol>\n<li>该线性读模式，每次Follower进行读请求时，需要和Leader同步日志提交位点信息，而Leader，需要向过半的Follower发起证明自己是Leader的轻量的RPC请求，相当于一个Follower读，至少需要1 + （n/2）+ 1 次的RPC请求。</li>\n</ol>\n</li>\n<li><strong>ReadOnlyLeaseBased</strong>\n<ol>\n<li>该线性读模式，每次Follower进行读请求时，Leader只需要判断自己的Leader租约是否过期了，如果没有过期，直接可以回复Follower自己是Leader，但是该机制对于机器时钟要求很严格，如果有做时钟同步的话，可以考虑使用该线性读模式。</li>\n</ol>\n</li>\n</ol>\n<p><a name=\"WiLDa\"></a></p>\n<h2>Nacos内嵌分布式ID</h2>\n<p>nacos内嵌的分布式ID为Snakeflower，dataCenterId默认为1，workerId的值计算方式如下</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-string\">InetAddress</span> <span class=\"hljs-string\">address;</span>\n<span class=\"hljs-string\">try</span> <span class=\"hljs-string\">{</span>\n\t<span class=\"hljs-string\">address</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">InetAddress.getLocalHost();</span>\n<span class=\"hljs-string\">}</span> <span class=\"hljs-string\">catch</span> <span class=\"hljs-string\">(final</span> <span class=\"hljs-string\">UnknownHostException</span> <span class=\"hljs-string\">e)</span> <span class=\"hljs-string\">{</span>\n\t<span class=\"hljs-string\">throw</span> <span class=\"hljs-string\">new</span> <span class=\"hljs-string\">IllegalStateException(</span>\n\t\t\t\t\t\t<span class=\"hljs-string\">\"Cannot get LocalHost InetAddress, please check your network!\"</span><span class=\"hljs-string\">);</span>\n<span class=\"hljs-string\">}</span>\n<span class=\"hljs-string\">byte[]</span> <span class=\"hljs-string\">ipAddressByteArray</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">address.getAddress();</span>\n<span class=\"hljs-string\">workerId</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">(((ipAddressByteArray[ipAddressByteArray.length</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-number\">2</span><span class=\"hljs-string\">]</span> <span class=\"hljs-string\">&amp;</span> <span class=\"hljs-string\">0B11)</span>\n\t\t\t\t\t<span class=\"hljs-string\">&lt;&lt;</span> <span class=\"hljs-string\">Byte.SIZE)</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">(ipAddressByteArray[ipAddressByteArray.length</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-number\">1</span><span class=\"hljs-string\">]</span>\n\t\t\t\t\t<span class=\"hljs-string\">&amp;</span> <span class=\"hljs-number\">0xFF</span><span class=\"hljs-string\">));</span>\n</code></pre>\n<p>如果需要手动指定dataCenterId以及workerId，则在application.properties或者启动时添加命令行参数</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-comment\">### set the dataCenterID manually</span>\n<span class=\"hljs-comment\"># nacos.core.snowflake.data-center=</span>\n<span class=\"hljs-comment\">### set the WorkerID manually</span>\n<span class=\"hljs-comment\"># nacos.core.snowflake.worker-id=</span>\n</code></pre>\n<p><a name=\"ZLp5w\"></a></p>\n<h2>Nacos内嵌的轻量的基于Derby的分布式关系型存储</h2>\n<p><a name=\"1B5KV\"></a></p>\n<h3>背景</h3>\n<ol>\n<li>如果配置文件数量较少，在集群模式下需要高可用数据库集群作为支撑的成本太大，期望有一个轻量的分布式关系型存储来解决</li>\n<li>nacos内部一些元数据信息存储，比如用户信息，命名空间信息</li>\n<li>思路来源：<a href=\"https://github.com/rqlite/rqlite\">https://github.com/rqlite/rqlite</a><br />\n<a name=\"Du2qc\"></a></li>\n</ol>\n<h3>设计思路</h3>\n<p><a name=\"NzxHa\"></a></p>\n<h4>目标</h4>\n<p>设计目标，是期望nacos存在两种数据存储模式，一种是现在的方式，数据存储在外置数据源（关系型数据库）；第二种方式是内嵌存储数据源（Apache Derby）。用户能够使用命令行参数配置的方式，随意使用这两种数据存储模式<br /><img src=\"https://cdn.nlark.com/yuque/0/2020/png/333972/1591015542106-f14d2579-229f-4bfb-a432-e40854e65d6d.png#align=left&amp;display=inline&amp;height=903&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=903&amp;originWidth=1514&amp;size=237497&amp;status=done&amp;style=none&amp;width=1514\" alt=\"image.png\">\n<a name=\"LqUtU\"></a></p>\n<h4>总体</h4>\n<p>将一次请求操作涉及的SQL上下文按顺序保存起来。然后通过一致协议层将本次请求涉及的SQL上下文进行同步，然后每个节点将其解析并重新按顺序在一次数据库会话中执行。<br /><img src=\"https://cdn.nlark.com/yuque/0/2020/png/333972/1587204104465-2270480a-de25-4c84-a11b-6edd2de99e66.png#align=left&amp;display=inline&amp;height=814&amp;margin=%5Bobject%20Object%5D&amp;name=%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%281%29.png&amp;originHeight=814&amp;originWidth=1149&amp;size=130886&amp;status=done&amp;style=none&amp;width=1149\" alt=\"未命名文件 (1).png\">\n<a name=\"yxFYn\"></a></p>\n<h4>谁可以处理请求</h4>\n<p>当使用者开启1.3.0的新特性——内嵌分布式关系型数据存储时，所有的写操作请求都将路由到Leader节点进行处理；但是，由于Raft状态机的特性，当某一个节点在apply数据库操作请求时发生非SQL逻辑错误引发的异常时，将导致状态机无法继续正常进行工作，此时将会触发配置管理模块的降级操作</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerSubscribe</span><span class=\"hljs-params\">()</span> </span>{\n\tNotifyCenter.registerSubscribe(<span class=\"hljs-keyword\">new</span> SmartSubscribe() {\n\n\t\t<span class=\"hljs-meta\">@Override</span>\n\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onEvent</span><span class=\"hljs-params\">(Event event)</span> </span>{\n\t\t\t<span class=\"hljs-keyword\">if</span> (event <span class=\"hljs-keyword\">instanceof</span> RaftDBErrorRecoverEvent) {\n\t\t\t\tdowngrading = <span class=\"hljs-keyword\">false</span>;\n\t\t\t\t<span class=\"hljs-keyword\">return</span>;\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">if</span> (event <span class=\"hljs-keyword\">instanceof</span> RaftDBErrorEvent) {\n\t\t\t\tdowngrading = <span class=\"hljs-keyword\">true</span>;\n\t\t\t}\n\t\t}\n\n\t\t<span class=\"hljs-meta\">@Override</span>\n\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">canNotify</span><span class=\"hljs-params\">(Event event)</span> </span>{\n\t\t\t<span class=\"hljs-keyword\">return</span> (event <span class=\"hljs-keyword\">instanceof</span> RaftDBErrorEvent) || (event <span class=\"hljs-keyword\">instanceof</span> RaftDBErrorRecoverEvent);\n\t\t}\n\t});\n}\n</code></pre>\n<p>因此，综上所述，可以通过活动图来理解下，什么情况下需要将请求进行转发\n<img src=\"https://cdn.nlark.com/yuque/__puml/db53c1ade61235d4c9659607b98ef7c6.svg#lake_card_v2=eyJjb2RlIjoiQHN0YXJ0dW1sXG5cbigqKSAtLT4gXCJGaWx0ZXIuZG9GaWx0ZXJcIlxuXG5pZiBcIuacrOiKgueCueaYr0xlYWRlclwiIHRoZW5cbiAgLWxlZnQtPlt0cnVlXSBcIuacrOiKgueCueWkhOeQhlwiXG4gIC0tPiAoKilcbmVsc2VcbiAgICBpZiBcIuezu-e7n-mZjee6p-W8gOWQr1wiIHRoZW5cbiAgICAgICAgLS0-W3RydWVdIFwi6L2s5Y-R57uZTGVhZGVyXCJcbiAgICAgICAgLS0-ICgqKVxuICAgIGVsc2VcbiAgICAgICAgaWYgXCLlhpnmk43kvZzor7fmsYJcIiB0aGVuXG4gICAgICAgICAgICAtLT5bdHJ1ZV0gXCLovazlj5Hnu5lMZWFkZXJcIlxuICAgICAgICAgICAgLS0-ICgqKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLT5bZmFsc2VdIFwi5pys6IqC54K55aSE55CGXCJcbiAgICAgICAgZW5kaWZcbiAgICBlbmRpZlxuZW5kaWZcblxuQGVuZHVtbCIsInR5cGUiOiJwdW1sIiwibWFyZ2luIjp0cnVlLCJpZCI6IjFuWW9HIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fcHVtbC9kYjUzYzFhZGU2MTIzNWQ0Yzk2NTk2MDdiOThlZjdjNi5zdmciLCJjYXJkIjoiZGlhZ3JhbSJ9\" alt=\"\"><a name=\"g1buf\"></a></p>\n<h4>相关数据承载对象</h4>\n<p>数据库的DML语句是select、insert、update、delete，根据SQL语句对于数据操作的性质，可以分为两大类：query以及update，select语句对应的是数据查询，insert、update、delete语句对应的是数据修改。同时在进行数据库操作时，为了避免SQL注入，使用的是PreparedStatement，因此需要SQL语句+参数，因此可以得到两个关于数据库操作的Request对象</p>\n<ol>\n<li>SelectRequest</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SelectRequest</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Serializable</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">long</span> serialVersionUID = <span class=\"hljs-number\">2212052574976898602L</span>;\n    <span class=\"hljs-comment\">// 查询类别，因为目前使用的是JdbcTemplate，查询单个、查询多个，是否使用RowMapper转为对象</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">byte</span> queryType;\n    <span class=\"hljs-comment\">// sql语句</span>\n    <span class=\"hljs-comment\">// select * from config_info where</span>\n    <span class=\"hljs-keyword\">private</span> String sql;\n    <span class=\"hljs-keyword\">private</span> Object[] args;\n    <span class=\"hljs-keyword\">private</span> String className;\n}\n</code></pre>\n<ol start=\"2\">\n<li>ModifyRequest</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ModifyRequest</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Serializable</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">long</span> serialVersionUID = <span class=\"hljs-number\">4548851816596520564L</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> executeNo;\n    <span class=\"hljs-keyword\">private</span> String sql;\n    <span class=\"hljs-keyword\">private</span> Object[] args;\n}\n</code></pre>\n<p><a name=\"moKl7\"></a></p>\n<h4>配置发布</h4>\n<p>配置发布操作涉及三个事务：</p>\n<ol>\n<li>config_info保存配置信息</li>\n<li>config_tags_relation保存配置与标签的关联关系</li>\n<li>his_config_info保存一条配置操作历史记录</li>\n</ol>\n<p>这三个事务都在配置发布这个大事务下，如果说我们对每个事务操作进行一个Raft协议提交，假设1、2两个事务通过Raft提交后都成功Apply了，第三个事务在进行Raft提交后apply失败，那么对于这个配置发布的大事务来说，是需要整体回滚的，否则就会违反原子性，那么可能需要说将事务回滚操作又进行一次Raft提交，那么整体的复杂程度上升，并且直接引入了分布式事务的管理，因此为了避免这个问题，我们将这三个事务涉及的SQL上下文进行整合成一个大的SQL上下文，对这大的SQL上下文进行Raft协议提交。保证了三个子事务在同一次数据库会话当中，成功解决原子性的问题，同时由于Raft协议对于事务日志的处理是串行执行的，因此相当于将数据库的事务隔离级别调整为串行化。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addConfigInfo</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> String srcIp,\n\t\t\t<span class=\"hljs-keyword\">final</span> String srcUser, <span class=\"hljs-keyword\">final</span> ConfigInfo configInfo, <span class=\"hljs-keyword\">final</span> Timestamp time,\n\t\t\t<span class=\"hljs-keyword\">final</span> Map&lt;String, Object&gt; configAdvanceInfo, <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">boolean</span> notify)</span> </span>{\n\n\t<span class=\"hljs-keyword\">try</span> {\n\t\t<span class=\"hljs-keyword\">final</span> String tenantTmp = StringUtils.isBlank(configInfo.getTenant()) ?\n\t\t\t\t\tStringUtils.EMPTY :\n\t\t\t\t\tconfigInfo.getTenant();\n\t\tconfigInfo.setTenant(tenantTmp);\n        \n        <span class=\"hljs-comment\">// 通过雪花ID算法获取数据库主键</span>\n\t\t<span class=\"hljs-keyword\">long</span> configId = idGeneratorManager.nextId(RESOURCE_CONFIG_INFO_ID);\n\t\t<span class=\"hljs-keyword\">long</span> hisId = idGeneratorManager.nextId(RESOURCE_CONFIG_HISTORY_ID);\n\n\t\taddConfigInfoAtomic(configId, srcIp, srcUser, configInfo, time,\n\t\t\t\t\tconfigAdvanceInfo);\n\t\tString configTags = configAdvanceInfo == <span class=\"hljs-keyword\">null</span> ?\n\t\t\t\t\t<span class=\"hljs-keyword\">null</span> :\n\t\t\t\t\t(String) configAdvanceInfo.get(<span class=\"hljs-string\">\"config_tags\"</span>);\n\n\t\taddConfigTagsRelation(configId, configTags, configInfo.getDataId(),\n\t\t\t\t\tconfigInfo.getGroup(), configInfo.getTenant());\n\t\tinsertConfigHistoryAtomic(hisId, configInfo, srcIp, srcUser, time, <span class=\"hljs-string\">\"I\"</span>);\n\t\tEmbeddedStorageContextUtils.onModifyConfigInfo(configInfo, srcIp, time);\n\t\tdatabaseOperate.blockUpdate();\n\t}\n\t<span class=\"hljs-keyword\">finally</span> {\n\t\tEmbeddedStorageContextUtils.cleanAllContext();\n\t}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-title\">addConfigInfoAtomic</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">long</span> id, <span class=\"hljs-keyword\">final</span> String srcIp,\n\t\t\t<span class=\"hljs-keyword\">final</span> String srcUser, <span class=\"hljs-keyword\">final</span> ConfigInfo configInfo, <span class=\"hljs-keyword\">final</span> Timestamp time,\n\t\t\tMap&lt;String, Object&gt; configAdvanceInfo)</span> </span>{\n\t...\n    <span class=\"hljs-comment\">// 参数处理</span>\n    ...\n\t<span class=\"hljs-keyword\">final</span> String sql =\n\t\t\t\t<span class=\"hljs-string\">\"INSERT INTO config_info(id, data_id, group_id, tenant_id, app_name, content, md5, src_ip, src_user, gmt_create,\"</span>\n\t\t\t\t\t\t+ <span class=\"hljs-string\">\"gmt_modified, c_desc, c_use, effect, type, c_schema) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)\"</span>;\n\t<span class=\"hljs-keyword\">final</span> Object[] args = <span class=\"hljs-keyword\">new</span> Object[] { id, configInfo.getDataId(),\n\t\t\t\tconfigInfo.getGroup(), tenantTmp, appNameTmp, configInfo.getContent(),\n\t\t\t\tmd5Tmp, srcIp, srcUser, time, time, desc, use, effect, type, schema, };\n\tSqlContextUtils.addSqlContext(sql, args);\n\t<span class=\"hljs-keyword\">return</span> id;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addConfigTagRelationAtomic</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">long</span> configId, String tagName, String dataId,\n\t\t\tString group, String tenant)</span> </span>{\n\t<span class=\"hljs-keyword\">final</span> String sql =\n\t\t\t\t<span class=\"hljs-string\">\"INSERT INTO config_tags_relation(id,tag_name,tag_type,data_id,group_id,tenant_id) \"</span>\n\t\t\t\t\t\t+ <span class=\"hljs-string\">\"VALUES(?,?,?,?,?,?)\"</span>;\n\t<span class=\"hljs-keyword\">final</span> Object[] args = <span class=\"hljs-keyword\">new</span> Object[] { configId, tagName, <span class=\"hljs-keyword\">null</span>, dataId, group,\n\t\t\t\ttenant };\n\tSqlContextUtils.addSqlContext(sql, args);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insertConfigHistoryAtomic</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">long</span> configHistoryId, ConfigInfo configInfo,\n\t\t\tString srcIp, String srcUser, <span class=\"hljs-keyword\">final</span> Timestamp time, String ops)</span> </span>{\n\t...\n    <span class=\"hljs-comment\">// 参数处理</span>\n    ...\n\t<span class=\"hljs-keyword\">final</span> String sql =\n\t\t\t\t<span class=\"hljs-string\">\"INSERT INTO his_config_info (id,data_id,group_id,tenant_id,app_name,content,md5,\"</span>\n\t\t\t\t\t\t+ <span class=\"hljs-string\">\"src_ip,src_user,gmt_modified,op_type) VALUES(?,?,?,?,?,?,?,?,?,?,?)\"</span>;\n\t<span class=\"hljs-keyword\">final</span> Object[] args = <span class=\"hljs-keyword\">new</span> Object[] { configHistoryId, configInfo.getDataId(),\n\t\t\t\tconfigInfo.getGroup(), tenantTmp, appNameTmp, configInfo.getContent(),\n\t\t\t\tmd5Tmp, srcIp, srcUser, time, ops };\n\n\tSqlContextUtils.addSqlContext(sql, args);\n}\n\n<span class=\"hljs-comment\">/**\n * Temporarily saves all insert, update, and delete statements under\n * a transaction in the order in which they occur\n *\n * <span class=\"hljs-doctag\">@author</span> &lt;a href=\"mailto:liaochuntao@live.com\"&gt;liaochuntao&lt;/a&gt;\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SqlContextUtils</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> ThreadLocal&lt;ArrayList&lt;ModifyRequest&gt;&gt; SQL_CONTEXT =\n            ThreadLocal.withInitial(ArrayList::<span class=\"hljs-keyword\">new</span>);\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addSqlContext</span><span class=\"hljs-params\">(String sql, Object... args)</span> </span>{\n        ArrayList&lt;ModifyRequest&gt; requests = SQL_CONTEXT.get();\n        ModifyRequest context = <span class=\"hljs-keyword\">new</span> ModifyRequest();\n        context.setExecuteNo(requests.size());\n        context.setSql(sql);\n        context.setArgs(args);\n        requests.add(context);\n        SQL_CONTEXT.set(requests);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;ModifyRequest&gt; <span class=\"hljs-title\">getCurrentSqlContext</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> SQL_CONTEXT.get();\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">cleanCurrentSqlContext</span><span class=\"hljs-params\">()</span> </span>{\n        SQL_CONTEXT.remove();\n    }\n\n}\n</code></pre>\n<p>通过一个时序图来更加直观的理解\n<img src=\"https://cdn.nlark.com/yuque/__puml/618e8997395fbc74433ac4a60f67b6b4.svg#lake_card_v2=eyJjb2RlIjoiQHN0YXJ0dW1sXG5cbmF1dG9udW1iZXJcblxuYWN0b3IgXCJVc2VyXCIgYXMgVXNlclxuXG5wYXJ0aWNpcGFudCBcIkNvbmZpZ1NlcnZpY2VcIiBhcyBTZXJ2aWNlXG5wYXJ0aWNpcGFudCBcIlBlcnNpc3RlbmNlU2VydmljZVwiIGFzIFJlcG9zaXRvcnlcbnBhcnRpY2lwYW50IFwiRGVyYnlcIiBhcyBEQlxucGFydGljaXBhbnQgXCJTUUxDb250ZXh0VXRpbHNcIiBhcyBTUUxDb250ZXh0XG5wYXJ0aWNpcGFudCBcIkxvZ1Byb2Nlc3NvclwiIGFzIFByb2Nlc3NvclxucGFydGljaXBhbnQgXCJDb25zaXN0ZW5jeVByb3RvY29sXCIgYXMgUHJvdG9jb2xcbnBhcnRpY2lwYW50IFwiTG9nXCIgYXMgTG9nXG5cbmFjdGl2YXRlIFVzZXJcblxuVXNlciAtPiBTZXJ2aWNlOiDlj5HotbfphY3nva7lj5HluIPor7fmsYJcbmFjdGl2YXRlIFNlcnZpY2VcblxuU2VydmljZSAtPiBSZXBvc2l0b3J5OiDphY3nva7lj5HluINcbmFjdGl2YXRlIFJlcG9zaXRvcnlcblxuUmVwb3NpdG9yeSAtPiBTUUxDb250ZXh0OiDmi6bmiKrlvZPliY1TUUzkuIrkuIvmlodcbmFjdGl2YXRlIFNRTENvbnRleHRcblxuUmVwb3NpdG9yeSAtPiBSZXBvc2l0b3J5OiBjb21taXQg5pON5L2cXG5cblNRTENvbnRleHQgLT4gUmVwb3NpdG9yeTog5b2T5YmN6K-35rGC5raJ5Y-K55qE5omA5pyJU1FM5LiK5LiL5paHXG5cbmRlYWN0aXZhdGUgU1FMQ29udGV4dFxuXG5SZXBvc2l0b3J5IC0-IExvZzog5p6E5bu66K-35rGC5L2TXG5cbmFjdGl2YXRlIExvZ1xuZGVhY3RpdmF0ZSBMb2dcblxuUmVwb3NpdG9yeSAtPiBQcm90b2NvbDogc3VibWl0KCkg6L-b6KGM6K-35rGC5o-Q5LqkXG5hY3RpdmF0ZSBQcm90b2NvbFxuZGVhY3RpdmF0ZSBSZXBvc2l0b3J5XG5cblByb3RvY29sIC0-IFByb2Nlc3Nvcjogb25BcHBseSgpIOaWueazle-8jOeKtuaAgeacuuWkjeWItkxvZ1xuYWN0aXZhdGUgUHJvY2Vzc29yXG5cblByb2Nlc3NvciAtPiBSZXBvc2l0b3J5OiDmiafooYzmiYDmnInnmoRTUUzkuIrkuIvmlodcbmFjdGl2YXRlIFJlcG9zaXRvcnlcblxuUmVwb3NpdG9yeSAtPiBEQjog5pWw5o2u6JC95bqTXG5hY3RpdmF0ZSBEQlxuXG5EQiAtPiBSZXBvc2l0b3J5OiDnu5PmnZ_lubbov5Tlm57nu5PmnpxcbmRlYWN0aXZhdGUgREJcblxuUmVwb3NpdG9yeSAtPiBQcm9jZXNzb3I6IOi_lOWbnkxvZ0Z1dHVyZeW5tuiuvue9ruacrOasoeaJp-ihjOeahOe7k-aenFxuZGVhY3RpdmF0ZSBSZXBvc2l0b3J5XG5cblByb2Nlc3NvciAtPiBQcm90b2NvbDog6L-U5ZueTG9nRnV0dXJlXG5kZWFjdGl2YXRlIFByb2Nlc3NvclxuXG5Qcm90b2NvbCAtPiBTZXJ2aWNlOiDmnKzmrKHor7fmsYLnmoTnu5PmnpxcbmRlYWN0aXZhdGUgUHJvdG9jb2xcblxuU2VydmljZSAtPiBVc2VyXG5kZWFjdGl2YXRlIFNlcnZpY2VcbmRlYWN0aXZhdGUgVXNlclxuXG5AZW5kdW1sIiwidHlwZSI6InB1bWwiLCJtYXJnaW4iOnRydWUsImlkIjoiVnQxNzciLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19wdW1sLzYxOGU4OTk3Mzk1ZmJjNzQ0MzNhYzRhNjBmNjdiNmI0LnN2ZyIsImNhcmQiOiJkaWFncmFtIn0=\" alt=\"\"><a name=\"AAJTE\"></a></p>\n<h3>如何使用新特性</h3>\n<pre><code class=\"language-bash\">./startup.sh -p embedded\n</code></pre>\n<p>是否启用内嵌的分布式关系型存储的活动图\n<img src=\"https://cdn.nlark.com/yuque/__puml/1fd656ba3b39fe5de8fea78efdf98dd1.svg#lake_card_v2=eyJjb2RlIjoiQHN0YXJ0dW1sXG5cbigqKSAtLT4gXCJDb25maWcuc3RhcnQoKVwiXG5cbmlmIFwi5Y2V5py65qih5byPXCIgdGhlblxuICAtcmlnaHQtPlt0cnVlXSBcInJldHVybiDpu5jorqTljZXmnLrlrZjlgqjooYzkuLpcIlxuICAtLT4gKCopXG5lbHNlXG4gaWYgXCLlt7LphY3nva7lpJbnva7lrZjlgqhcIiB0aGVuXG4gICAgLS0-W3RydWVdIFwicmV0dXJuIOWklue9ruaVsOaNruWtmOWCqOihjOS4ulwiXG4gICAgLS0-ICgqKVxuIGVsc2VcbiAgICBpZiBcIuW8gOWQr-WGheW1jOWtmOWCqFwiIHRoZW5cbiAgICAgICAgLS0-W3RydWVdIFwicmV0dXJuIOi9u-mHj-WGheW1jOWIhuW4g-W8j-WtmOWCqOihjOS4ulwiXG4gICAgICAgIC0tPiAoKilcbiAgICBlbHNlXG4gICAgICAgIC0-W2ZhbHNlXSBcInJldHVybiDpu5jorqTlpJbnva7mlbDmja7lrZjlgqjooYzkuLpcIlxuICAgICAgICAtLT4gKCopXG5cdFx0ZW5kaWZcbiBlbmRpZlxuZW5kaWZcblxuQGVuZHVtbCIsInR5cGUiOiJwdW1sIiwibWFyZ2luIjp0cnVlLCJpZCI6IkNNN1VDIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fcHVtbC8xZmQ2NTZiYTNiMzlmZTVkZThmZWE3OGVmZGY5OGRkMS5zdmciLCJjYXJkIjoiZGlhZ3JhbSJ9\" alt=\"\"><a name=\"9UAXN\"></a></p>\n<h3>新特性的相关运维操作</h3>\n<p>直接查询每个节点的derby存储的数据</p>\n<pre><code class=\"language-java\">GET /nacos/v1/cs/ops/derby?sql=select * from config_info\n\n<span class=\"hljs-keyword\">return</span> List&lt;Map&lt;String, Object&gt;&gt;\n</code></pre>\n<p><a name=\"YcqO2\"></a></p>\n<h3>不足</h3>\n<ol>\n<li>在数据库上层构建一层分布式数据操作同步层，对数据库的操作存在了限制，比如第一步insert操作，然后select操作，最后在update操作，这种在数据修改语句中穿插着查询语句的操作顺序是不支持的</li>\n<li>限制了数据库的性能，由于间接的将数据库事务隔离级别调整为了串行化，人为的将并发能力降低了\n<a name=\"7dul8\"></a></li>\n</ol>\n<h3>未来演进</h3>\n<p>将于Apache Derby官方一起尝试基于Raft实现BingLog的同步复制操作，从底层实现数据库同步能力</p>\n",
  "link": "\\zh-cn\\blog\\nacos-1.3.0-design.html",
  "meta": {
    "title": "Nacos 1.3.0 全新内核构建过程",
    "keywords": "nacos1.3.0,内核",
    "description": "Nacos 1.3.0 全新内核构建过程"
  }
}