---
title: Nacos 健康检查机制
keywords: [ Nacos ]
description: 程露 Nacos committer在上文中，我们介绍了 Nacos 注册中心中的服务数据模型，说明了服务、实例以及集群的内容，关系及它们的生命周期。期间健康检查是一个被反复提及的词语，这是由于注册中心不应该仅仅提供服务注册和发现功能，还应该保证对服务可用性进行监测，对不健康和过期的服务实例进...
---
> 程露 Nacos committer

在上文中，我们介绍了 Nacos 注册中心中的服务数据模型，说明了服务、实例以及集群的内容，关系及它们的生命周期。期间健康检查是一个被反复提及的词语，这是由于注册中心不应该仅仅提供服务注册和发现功能，还应该保证对服务可用性进行监测，对不健康和过期的服务实例进行标识或剔除，维护实例的生命周期，以保证客户端尽可能的查询到可用的服务列表。因此本文将详细介绍 Nacos 注册中心中的健康检查机制。
<a name="Sr4NB"></a>
# 注册中心的健康检查机制
想象一下这么一个场景，你所在的地区突然发生地质灾害，你被掩盖在废墟下面，搜救队必须要知道你在废墟里面那么才能对你进行施救。那么有什么方法可以让救援队知道你在废墟下面？第一种，你在废墟里面大喊help! help! I am here! ，让搜救队知道你的位置和健康状态。第二种，搜救队使用了他们的专业检查设备，探测到你正埋在废墟下面。<br />这两种检查方式其实也可以类比到我们对于服务的探测，我们需要知道一个服务是否还健康。那么第一种方式是客户端主动上报，告诉服务端自己健康状态，如果在一段时间没有上报，那么我们就认为服务已经不健康。第二种，则是服务端主动向客户端进行探测，检查客户端是否还被能探测到。<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/110282/1638270171464-56f02ca9-70ae-4a7e-bf84-b4bdb4f0dd9d.png#clientId=ueaeac162-44c2-4&from=paste&height=384&id=u7a2688d4&originHeight=384&originWidth=719&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18638&status=done&style=none&taskId=u70a66886-cf07-45d3-81c4-7b0179ca297&title=&width=719)<br />再回到前面的场景中，如果是你在废墟中大声呼叫救援队并且提供你的位置和健康信息，那么相比于搜救队用探测设备挨着废墟探测会使探测队的工作量减轻很多，那么他可以专注于尽快将你救出。这也好比于注册中心对于服务健康状态的检测，如果所有服务都需要注册中心去主动探测，由于服务的数量远大于注册中心的数量，那么注册中心的任务量将会比较巨大。所以我们自然而然会想到，那就都采用服务主动上报的方式进行健康检查。那如果在废墟之下的我们因为身体状况无法呼救，那么搜救队就会放弃搜救了吗？当然不是，搜救队肯定也会对废墟进行全面探测将你救出。类比到服务健康检查，如果服务本身就没法主动进行健康上报，那么这个时候注册中心主动检查健康状态就有用武之地了。<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/110282/1638270723227-97d26356-b5f8-4dcd-9169-d946e895490f.png#clientId=ub93ddd55-cd28-4&from=paste&height=387&id=u0a3df357&originHeight=387&originWidth=438&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16417&status=done&style=none&taskId=u9d838155-892e-487a-bc22-f091458d7b9&title=&width=438)<br />在当前主流的注册中心，对于健康检查机制主要都采用了 TTL（Time To Live）机制，即客户端在一定时间没有向注册中心发送心跳，那么注册中心会认为此服务不健康，进而触发后续的剔除逻辑。对于主动探测的方式那么根据不同的场景，需要采用的方式可能会有不同。
<a name="xXHZG"></a>
# Nacos 健康检查机制
既然以上两种健康检查机制都有应用的场景，且适用场景不一致，那么 Nacos 对于健康检查的机制又是如何抉择的呢？<br />在介绍 Nacos 的健康检查机制之前，我们先回顾一下 Nacos 服务有什么特点。Nacos 提供了两种服务类型供用户注册实例时选择，分为非持久化实例（又称临时实例）和持久化实例（又称永久实例）。<br />临时实例只是临时存在于注册中心中，会在服务下线或不可用时被注册中心剔除，临时实例会与注册中心保持心跳，注册中心会在一段时间没有收到来自客户端的心跳后会将实例设置为不健康，然后在一段时间后进行剔除。<br />永久实例在被删除之前会永久的存在于注册中心，且有可能并不知道注册中心存在，不会主动向注册中心上报心跳，那么这个时候就需要注册中心主动进行探活。<br />从上面的介绍我们可以看出，Nacos 中两种健康探测方式均有被使用，Nacos 中健康检查的整体交互如下如所示。下面我们会详细介绍 Nacos 中对于两种实例的健康检查机制。<br />![Nacos两种实例健康检查机制](https://cdn.nlark.com/yuque/0/2020/png/1465210/1598000047612-f1ea83bb-67c4-4c92-83ef-1e29f9f3370c.png#from=url&height=352&id=p6ETm&originHeight=368&originWidth=564&originalType=binary&ratio=1&rotation=0&showTitle=true&status=done&style=none&title=Nacos%E4%B8%A4%E7%A7%8D%E5%AE%9E%E4%BE%8B%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6&width=539 "Nacos两种实例健康检查机制")
<a name="UPeu3"></a>
## 临时实例健康检查机制
在 Nacos 中，用户可以通过两种方式进行临时实例的注册，通过 Nacos 的 OpenAPI 进行服务注册或通过 Nacos 提供的 SDK 进行服务注册。<br />OpenAPI 的注册方式实际是用户根据自身需求调用 Http 接口对服务进行注册，然后通过 Http 接口发送心跳到注册中心。在注册服务的同时会注册一个全局的客户端心跳检测的任务。在服务一段时间没有收到来自客户端的心跳后，该任务会将其标记为不健康，如果在间隔的时间内还未收到心跳，那么该任务会将其剔除。<br />SDK 的注册方式实际是通过 RPC 与注册中心保持连接（Nacos 2.x 版本中，旧版的还是仍然通过 OpenAPI 的方式），客户端会定时的通过 RPC 连接向 Nacos 注册中心发送心跳，保持连接的存活。如果客户端和注册中心的连接断开，那么注册中心会主动剔除该 client 所注册的服务，达到下线的效果。同时 Nacos 注册中心还会在注册中心启动时，注册一个过期客户端清除的定时任务，用于删除那些健康状态超过一段时间的客户端。<br />从上面的特点我们可以发现，对于不同类型的使用方式，Nacos 对于健康检查的特点实际都是相同的，都是由客户端向注册中心发送心跳，注册中心会在连接断开或是心跳过期后将不健康的实例移除。<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/110282/1638273950553-3d7003f1-4704-49d7-8920-b16238c3447a.png#clientId=uc139c711-0875-4&from=paste&height=215&id=u6d9be578&originHeight=215&originWidth=709&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18446&status=done&style=none&taskId=udde82e0f-76f3-4edc-8836-8bc5a5d08b2&title=&width=709)
<a name="R8wc3"></a>
## 永久实例健康检查机制
Nacos 中使用 SDK 对于永久实例的注册实际也是使用 OpenAPI 的方式进行注册，这样可以保证即使是客户端下线后也不会影响永久实例的健康检查。<br />对于永久实例的的健康检查，Nacos 采用的是注册中心探测机制，注册中心会在持久化服务初始化时根据客户端选择的协议类型注册探活的定时任务。Nacos 现在内置提供了三种探测的协议，即 Http、TCP 以及 MySQL 。一般而言 Http 和 TCP 已经可以涵盖绝大多数的健康检查场景。MySQL 主要用于特殊的业务场景，例如数据库的主备需要通过服务名对外提供访问，需要确定当前访问数据库是否为主库时，那么我们此时的健康检查接口，是一个检查数据库是否为主库的 MySQL 命令。<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/110282/1638273966070-17a3b2e7-124e-46ad-8221-1f904f0cac14.png#clientId=uc139c711-0875-4&from=paste&height=368&id=ub890028c&originHeight=368&originWidth=676&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24794&status=done&style=none&taskId=u7cf9877c-2b43-498c-88a0-344e2d4100b&title=&width=676)<br />由于持久化服务的实例的在被主动删除前一直存在的特性，探活的定时任务会不断探测服务的健康状态，并且将无法探测成功的实例标记为不健康。但是有些时候会有这样的场景，有些服务不希望去校验其健康状态，Nacos也是提供了对应的白名单配置，用户可以将服务配置到该白名单，那么 Nacos 会放弃对其进行健康检查，实例的健康状态也始终为用户传入的健康状态。
<a name="GnnHL"></a>
# 集群模式下的健康检查机制
一个完整的注册中心，是应该具备高可用的特性，即我们的注册中心是可以集群部署作为一个整体对外提供服务，当然 Nacos 也支持这样的特性。不同于单机部署，集群部署中我们的客户端只和其中一个注册中心服务保持链接和请求，但是我们的服务信息需要注册到所有的服务节点上，在其他客户端从任意一个注册中心服务获取服务列表时始终是所有的服务列表。在这种情况下，那么 Nacos 在集群模式下又是如何对不是和自己保持心跳连接的服务进行健康检查的呢？<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/110282/1638272281774-a3f3d7f4-6f28-409f-ace4-b6ee0661c03c.png#clientId=u074ac9c3-97e3-4&from=paste&height=577&id=u05e8e689&originHeight=577&originWidth=1022&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36534&status=done&style=none&taskId=ucadad689-7c74-4236-9f31-d1b527d6a4a&title=&width=1022)<br />对于集群下的服务，Nacos 一个服务只会被 Nacos 集群中的一个注册中心所负责，其余节点的服务信息只是集群副本，用于订阅者在查询服务列表时，始终可以获取到全部的服务列表。临时实例只会对其被负责的注册中心节点发送心跳信息，注册中心服务节点会对其负责的永久实例进行健康探测，在获取到健康状态后由当前负责的注册中心节点将健康信息同步到集群中的其他的注册中心。<br />在Nacos中，服务的注册我们从注册方式维度实际可以分为两大类。第一类通过 SDK RPC 连接进行注册，客户端会和注册中心保持链接。第二类，通过 OpenAPI 进行 IP 和端口注册。<br />对于第一类，如何寻找到对其负责的注册中心节点呢？聪明的你肯定想到了，只需要和注册中心集群中的任意一台节点建立联系，那么由这个节点负责这个客户端就可以了。注册中心会在启动时注册一个全局的同步任务，用于将其当前负责的所有节点信息同步到集群中的其他节点，其他非负责的节点也会创建该客户端的信息，在非负责的节点上，连接类型的客户端，会有一个续约时间的概念，在收到其他节点的同步信息时，更新续约时间为当前时间，如果在集群中的其他节点在一段时间内没有收到不是自己的负责的节点的同步信息，那么认为此节点已经不健康，从而达到对不是自己负责的节点健康状态检查。<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/110282/1638274280729-48552ed3-f4b8-4117-a1ef-c8cf1f803cbd.png#clientId=ucddaa51e-1355-4&from=paste&height=394&id=u4aff34af&originHeight=394&originWidth=806&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35145&status=done&style=none&taskId=uba9f9e04-5b67-4625-99db-b68c511f500&title=&width=806)<br />对于第二类，方式其实也基本和第一类一致，OpenAPI 注册的临时实例也是通过同步自身负责的节点到其他节点来更新其他节点的对应的临时实例的心跳时间，保证其他节点不会删除或者修改此实例的健康状态。前面我们特别特别指明了是临时实例而没有说所有实例，你应该也可能会想到这种方式对于持久化节点的会显得多余，永久实例会在被主动删除前一直存在于注册中心，那么我们健康检查并不会去删除实例，所以我们只需要在负责的节点永久实例健康状态变更的时候通知到其余的节点即可。<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/110282/1638273908494-4fb0a890-d4dc-4db5-8976-c2fa96fddf04.png#clientId=u401c3b16-0bbf-4&from=paste&height=422&id=ub22fe09c&originHeight=422&originWidth=783&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36230&status=done&style=none&taskId=u11ded4bb-bc3a-4bd2-b446-590fd678d8c&title=&width=783)
<a name="OGdrd"></a>
# 小结

本文从注册中心场景展开，详细介绍了 Nacos 注册中心的健康检查机制。在 Nacos 中，针对不同类型的服务将会使用不同的健康检查方式进行实例生命周期的维护，并通过前文提到的一致性协议使 Nacos 节点均能够保持实例生命周期的一致。从本文开始，我们提及了 Nacos 注册中心集群中，实例的健康状态和生命周期需要保持一致，因此在下文中，我们将开始介绍 Nacos 注册中心是如何使用 Nacos 的一致性协议，来保持数据模型及生命周期一致。
