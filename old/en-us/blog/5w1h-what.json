{
  "filename": "5w1h-what.md",
  "__html": "<h1>What problems does Nacos help us solve? —— Configuration Management</h1>\n<blockquote>\n<p>Authors: He Xu</p>\n</blockquote>\n<h2>Overview</h2>\n<p><a href=\"https://github.com/alibaba/nacos\">Nacos</a> is Alibaba's open source project in July 2018 this year,As its name, Naming and Configuration Service ,Focus on service discovery and configuration management。This series of articles,We will fully analyze Nacos from 5W1H（What、Where、When、Who、Why、How）,I hope it will be helpful to developers when selecting open source solutions for service discovery and configuration management。</p>\n<p>This article serves as the beginning of the Nacos series,Start with &quot;What&quot;。When we started to pay attention to an open source project,Usually the first two questions that come to mind are:</p>\n<ul>\n<li>What is it？</li>\n<li>What problem does it help us to solve?</li>\n</ul>\n<p>What is it？</p>\n<p>Nacos is a dynamic service discovery, configuration management and service management platform that makes it easier to build Cloud Native applications.</p>\n<p>What problem does it help us to solve?</p>\n<p>This article will first focus on its &quot;configuration management&quot; function to answer。&quot;Configuration&quot;,As a buddy with the code,Accompanied by the entire life cycle of the application,Of course we are also very familiar with it,Think about how many forms of configuration generally exist?</p>\n<ul>\n<li>Hard-Code</li>\n<li>Configuration file</li>\n<li>Database configuration table</li>\n</ul>\n<h2>Hard-Code</h2>\n<p>Configuration items exist in the form of class fields.\nE.g:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppConfig</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> connectTimeoutInMills = <span class=\"hljs-number\">5000</span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getConnectTimeoutInMills</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> connectTimeoutInMills;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setConnectTimeoutInMills</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> connectTimeoutInMills)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.connectTimeoutInMills = connectTimeoutInMills;\n    }\n}\n</code></pre>\n<p>There are three main problems with this approach:</p>\n<p>If the configuration needs to be modified dynamically,The current application is required to expose the interface for managing the configuration item,As for the Controller's API interface, or JMX, it can be done.</p>\n<p>In addition, configuration changes occur in memory and are not persisted.Therefore, restart the application after modifying the configuration, and the configuration will change back to the default value in the code,This is harmful, I have encountered.</p>\n<p>Last question,When you have multiple machines,Need to modify a configuration,Every one has to be revised,The cost is very high.</p>\n<h2>Configuration file</h2>\n<p>In Spring,properties or ymal or other custom configuration files, such as &quot;conf&quot; suffix：</p>\n<pre><code># application.properties\nconnectTimeoutInMills=5000\n</code></pre>\n<p>Compared to the &quot;hard-code&quot; form,It solves the second problem,Persistent configuration.However, the other two issues are not resolved,Operation and maintenance costs are still high.</p>\n<p>Dynamic configuration changes,It can be through a similar &quot;hard-code&quot; way to expose the management interface,At this time, there will be one more step in the code to persist the logic of the new configuration to the file. Or, simple and rude,Log in to the machine directly to modify the configuration file,And then restart the app,Let the configuration take effect. Of course, you can also add a timing task to the code,For example, read the content of the configuration file every 10s, so that the latest configuration can take effect in the application in time, so that the &quot;heavier&quot; operation and maintenance operation of restarting the application is eliminated.</p>\n<p>By adding &quot;persistent logic&quot; and &quot;timed tasks&quot;, the form of &quot;configuration files&quot; is a small step forward than &quot;hard-code&quot;.</p>\n<h2>Database configuration table</h2>\n<p>Database can be a relational database such as MySQL or a non-relational database such as Redis. The data table is as follows：</p>\n<pre><code class=\"language-sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> <span class=\"hljs-string\">`config`</span> (\n  <span class=\"hljs-string\">`id`</span> <span class=\"hljs-built_in\">bigint</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span> AUTO_INCREMENT,\n  <span class=\"hljs-string\">`key`</span> <span class=\"hljs-built_in\">varchar</span>(<span class=\"hljs-number\">50</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span> <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-string\">''</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">'配置项'</span>,\n  <span class=\"hljs-string\">`value`</span> <span class=\"hljs-built_in\">varchar</span>(<span class=\"hljs-number\">50</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span> <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-string\">''</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">'配置内容'</span>,\n  <span class=\"hljs-string\">`updated_time`</span> <span class=\"hljs-built_in\">timestamp</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span> <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">CURRENT_TIMESTAMP</span> <span class=\"hljs-keyword\">ON</span> <span class=\"hljs-keyword\">UPDATE</span> <span class=\"hljs-keyword\">CURRENT_TIMESTAMP</span>,\n  <span class=\"hljs-string\">`created_time`</span> <span class=\"hljs-built_in\">timestamp</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span> <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">CURRENT_TIMESTAMP</span>,\n  PRIMARY <span class=\"hljs-keyword\">KEY</span> (<span class=\"hljs-string\">`id`</span>),\n  <span class=\"hljs-keyword\">UNIQUE</span> <span class=\"hljs-keyword\">KEY</span> <span class=\"hljs-string\">`idx_key`</span> (<span class=\"hljs-string\">`key`</span>)\n) <span class=\"hljs-keyword\">ENGINE</span>=<span class=\"hljs-keyword\">InnoDB</span> <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">CHARSET</span>=utf8 <span class=\"hljs-keyword\">COMMENT</span>=<span class=\"hljs-string\">'配置信息'</span>;\n\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> <span class=\"hljs-string\">`config`</span> (<span class=\"hljs-string\">`key`</span>, <span class=\"hljs-string\">`value`</span>, <span class=\"hljs-string\">`updated_time`</span>, <span class=\"hljs-string\">`created_time`</span>) <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">'connectTimeoutInMills'</span>, <span class=\"hljs-string\">'5000'</span>, <span class=\"hljs-keyword\">CURRENT_TIMESTAMP</span>, <span class=\"hljs-keyword\">CURRENT_TIMESTAMP</span>);\n</code></pre>\n<p>Compared with the first two, it takes the configuration a step further, separates the configuration from the application, and centrally manages it, which can greatly reduce the operation and maintenance cost.</p>\n<p>So, how can it solve the problem of dynamically updating the configuration? As far as I know, there are two ways。</p>\n<p>One,Same as before,Solve by exposing management interface,Of course,Also need to increase the logic of persistence,But before it was to write files, now it is to write the latest configuration to the database. However, the program also needs to periodically read the latest configuration task from the database, so that only by calling the management configuration interface of one of the machines, the latest configuration can be distributed to all the machines in the entire application cluster. Really achieve the purpose of reducing operation and maintenance costs.</p>\n<p>Second,Modify the database directly, and read the latest configuration content from the database through timed tasks in the program.</p>\n<p>The form of &quot;Database configuration table&quot; solves the main problem, but it is not elegant enough and brings some &quot;cumbersome&quot;.</p>\n<h2>Nacos configuration management</h2>\n<p>Nacos truly separates the configuration from the application, manages it in a unified way, and elegantly solves the problems of dynamic changes, persistence, operation and maintenance costs of the configuration.</p>\n<p>The application itself does not need to add a management configuration interface, nor does it need to implement configuration persistence by itself, and it does not need to introduce &quot;timed tasks&quot; in order to reduce operation and maintenance costs. Nacos The provided configuration management function gathers all the logic related to the configuration, and provides a simple and easy-to-use SDK, so that the configuration of the application can be easily managed by Nacos.</p>\n<p>If you are using Nacos in Spring, you only need three steps:</p>\n<ol>\n<li>Add dependency</li>\n</ol>\n<pre><code class=\"language-plain\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;\n    &lt;artifactId&gt;nacos-spring-context&lt;/artifactId&gt;\n    &lt;version&gt;${latest.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<ol start=\"2\">\n<li>Add <code>@EnableNacosConfig</code> annotation,Enable Nacos Spring's configuration management service。In the following example, we use <code>@NacosPropertySource</code> to load the configuration source with <code>dataId</code> as <code>example</code> and enable automatic update:</li>\n</ol>\n<pre><code class=\"language-plain\">@Configuration\n@EnableNacosConfig(globalProperties = @NacosProperties(serverAddr = &quot;127.0.0.1:8848&quot;))\n@NacosPropertySource(dataId = &quot;example&quot;, autoRefreshed = true)\npublic class NacosConfiguration {\n\n}\n</code></pre>\n<ol start=\"3\">\n<li>Set the attribute value through Spring's <code>@Value</code> annotation.</li>\n</ol>\n<p>Note: You need to have the <code>Setter</code> method at the same time to automatically update when the configuration changes.</p>\n<pre><code class=\"language-plain\">public class AppConfig {\n\n    @Value(&quot;${connectTimeoutInMills:5000}&quot;)\n    private int connectTimeoutInMills;\n\n    public int getConnectTimeoutInMills() {\n        return connectTimeoutInMills;\n    }\n\n    public void setConnectTimeoutInMills(int connectTimeoutInMills) {\n        this.connectTimeoutInMills = connectTimeoutInMills;\n    }\n}\n</code></pre>\n<p>The above three steps have almost no code intrusion to the application itself,1 dependency 2 annotations,With just a few lines, the configuration is managed through Nacos.</p>\n<p>About the dynamic update of the configuration,For users of Nacos Spring, it is just a boolean value of &quot;autoRefreshed&quot; that is set in their own application。Then when you need to modify the configuration, call Nacos to modify the configuration interface, or use the Nacos console to modify. After the configuration is changed, Nacos will push the latest configuration to all the machines of the application, which is simple and efficient.</p>\n<p>Think about it before, in order to realize this function, how much wrong code was written, and how much tedious operation and maintenance work was done. It would be great if you had met Nacos earlier!</p>\n<h2>Summary</h2>\n<p>This article serves as the beginning of the Nacos 5W1H series,&quot;What&quot; tells the problem that Nacos configuration management can help us solve: manage configuration in a simple, elegant, and efficient way, realize dynamic configuration changes, greatly reduce operation and maintenance costs, and let developers leave work earlier.</p>\n<p>Of course, Nacos configuration management is not only the above-mentioned functions, but also such as &quot;gray release&quot;, &quot;version management&quot;, &quot;fast rollback&quot;, &quot;monitor query&quot;, &quot;push trajectory&quot;, &quot;authority control&quot;, &quot;Encrypted storage of sensitive configuration (eg, database connection configuration)&quot; etc.. Some of these have been implemented in open source in Nacos, and some are provided in the free product of Alibaba Cloud <a href=\"https://cn.aliyun.com/product/acm\">ACM</a> of Nacos configuration management. Of course, the follow-up will be slow Slowly open source to Nacos, so stay tuned.</p>\n<p>This series of articles,Will continue to tell everyone about Nacos bit by bit,It's not just about &quot;What problem can Nacos help us solve?&quot;,There will also be an in-depth source code analysis &quot;How is Nacos simple and powerful?&quot;。At the same time, if the guys are interested, we will also give you gossip about Nacos' history of barnyard officials, about the history of Nacos in Ali, about the meaning of the Nacos service port, etc.. In short, one sentence: I have a story, and I also have a good wine, what else can you ask for?</p>\n",
  "link": "/en-us/blog/5w1h-what.html",
  "meta": {
    "title": "What problems does Nacos help us solve? —— Configuration Management",
    "keywords": "nacos",
    "description": "What problems can Nacos configuration management help us solve?"
  }
}