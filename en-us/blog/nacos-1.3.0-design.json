{
  "filename": "nacos-1.3.0-design.md",
  "__html": "<h1>Nacos 1.3.0 Documentation of features and functionality</h1>\n<p><a name=\"0YIG0\"></a></p>\n<h2>Summarize</h2>\n<p>This 1.3.0 is implanted to a great extent, involving the modification of two large modules and the addition of a core module</p>\n<ol>\n<li>nacos-core module modification\n<ol>\n<li>nacos</li>\n<li>nacos internal event mechanism</li>\n<li>nacos consistency protocol layer</li>\n</ol>\n</li>\n<li>nacos-config module modification\n<ol>\n<li>Add embedded distributed data storage components</li>\n<li>Separation of embedded storage and external storage</li>\n<li>Simple operation and maintenance of embedded storage</li>\n</ol>\n</li>\n<li>Add nacos-consistency module\n<ol>\n<li>Unified abstraction for AP protocol and CP protocol</li>\n</ol>\n</li>\n</ol>\n<br />\n<p><a name=\"rnkDY\"></a></p>\n<h2>System parameters changes</h2>\n<p><a name=\"1Gmg9\"></a></p>\n<h3>Updates</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>core</strong></th>\n<th>nacos.watch-file.max-dirs</th>\n<th>JVM parameter</th>\n<th>Maximum number of monitored directories</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n<td>nacos.core.notify.ring-buffer-size</td>\n<td>JVM parameter</td>\n<td>Quick notification of the maximum length of the queue</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td>nacos.core.notify.share-buffer-size</td>\n<td>JVM parameter</td>\n<td>The maximum length of the slow notification queue</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td>nacos.core.member.fail-access-cnt</td>\n<td>JVM parameter.properties</td>\n<td>Maximum number of failed visits to cluster member nodes</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td>nacos.core.address-server.retry</td>\n<td>JVM parameter、application.properties</td>\n<td>Address server addressing mode, first start request retry times</td>\n</tr>\n</tbody>\n</table>\n<br />\n<p><a name=\"kxo8O\"></a></p>\n<h2>The future overall logical architecture of Nacos and its components</h2>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/333972/1587129046320-5a286f38-8db4-4e76-9b42-8bd859f51a60.png#align=left&amp;display=inline&amp;height=1184&amp;margin=%5Bobject%20Object%5D&amp;name=1561217775318-6e408805-18bb-4242-b4e9-83c5b929b469.png&amp;originHeight=1184&amp;originWidth=1608&amp;size=279074&amp;status=done&amp;style=none&amp;width=1608\" alt=\"1561217775318-6e408805-18bb-4242-b4e9-83c5b929b469.png\"></p>\n<p><a name=\"Hyc6u\"></a></p>\n<h2>Nacos cluster member node addressing mode</h2>\n<p><br />Before 1.3.0, nacos' naming module and config module had their own member list management tasks. In order to unify the replacement mode of nacos assigning the next member list, the implementation of merge management is replaced from the named module and the config module, unified to the addressing module of the core module, and the command line parameters are added at the same time -Dnacos.member.list **To set the list listed by nacos, this parameter can be called an alternative to the cluster.conf file. The current nacos addressing mode categories are as follows</p>\n<ol>\n<li>In stand-alone mode: StandaloneMemberLookup</li>\n<li>Play mode\n<ol>\n<li>The cluster.conf file exists: FileConfigMemberLookup</li>\n<li>The cluster.conf file does not exist or -Dnacos.member.list is not set: AddressServerMemberLookup</li>\n</ol>\n</li>\n</ol>\n<p>If you want to specify an addressing mode, set this parameter：<strong>nacos.core.member.lookup.type=[file,address-server]</strong></p>\n<p>The logical diagram is as follows\n<img src=\"https://cdn.nlark.com/yuque/__puml/e209a677aa8b5ffce23589e987ee5129.svg#lake_card_v2=eyJjb2RlIjoiQHN0YXJ0dW1sXG5cbigqKSAtLT4gXCJMb29rdXBGYWN0b3J5LmluaXQoKVwiXG5cbmlmIFwic3RhbmRhbG9uZSBtb2RlXCIgdGhlblxuICAtLT5bdHJ1ZV0gXCJyZXR1cm4gU3RhbmRhbG9uZU1lbWJlckxvb2t1cFwiXG4gIC0tPiBMb29rdXAucnVuKClcbmVsc2VcbiBpZiBcImNsdXN0ZXIuY29uZiBleGlzdHNcIiB0aGVuXG4gICAgLS0-W3RydWVdIFwicmV0dXJuIEZpbGVDb25maWdNZW1iZXJMb29rdXBcIlxuICAgIC0tPiBMb29rdXAucnVuKClcbiBlbHNlXG4gICAgLT5bZmFsc2VdIFwicmV0dXJuIEFkZHJlc3NTZXJ2ZXJNZW1iZXJMb29rdXBcIlxuICAgIC0tPiBMb29rdXAucnVuKClcbiBlbmRpZlxuZW5kaWZcblxuLS0-ICgqKVxuXG5AZW5kdW1sIiwidHlwZSI6InB1bWwiLCJpZCI6IlplWGtkIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fcHVtbC9lMjA5YTY3N2FhOGI1ZmZjZTIzNTg5ZTk4N2VlNTEyOS5zdmciLCJjYXJkIjoiZGlhZ3JhbSJ9\" alt=\"\"></p>\n<p><a name=\"wqkMp\"></a></p>\n<h3>Addressing mode details</h3>\n<p>Next, I introduce two other addressing modes in addition to the addressing mode in stand-alone mode<br /></p>\n<p><a name=\"egl3H\"></a></p>\n<h4>FileConfigMemberLookup</h4>\n<p>This addressing mode is managed based on the cluster.conf file, and each node will read the list of member nodes in the cluster.conf file under their respective ${nacos.home}/conf and then form a cluster. And after reading the cluster.conf file under ${nacos.home}/conf for the first time, it will automatically register a directory listener with the operating system's <em><strong>inotify</strong></em> mechanism to monitor ${nacos.home}/ All file changes in the conf directory (note that only files will be monitored here, and file changes in subdirectories cannot be monitored)<br />When you need to expand or shrink the cluster nodes, you need to manually modify the content of the member node list of cluster.conf under ${nacos.home}/conf for each node.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> FileWatcher watcher = <span class=\"hljs-keyword\">new</span> FileWatcher() {\n\t\t<span class=\"hljs-meta\">@Override</span>\n\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onChange</span><span class=\"hljs-params\">(FileChangeEvent event)</span> </span>{\n\t\t\treadClusterConfFromDisk();\n\t\t}\n\n\t\t<span class=\"hljs-meta\">@Override</span>\n\t\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">interest</span><span class=\"hljs-params\">(String context)</span> </span>{\n\t\t\t<span class=\"hljs-keyword\">return</span> StringUtils.contains(context, <span class=\"hljs-string\">\"cluster.conf\"</span>);\n\t\t}\n};\n\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> NacosException </span>{\n\treadClusterConfFromDisk();\n\n\t<span class=\"hljs-keyword\">if</span> (memberManager.getServerList().isEmpty()) {\n\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> NacosException(NacosException.SERVER_ERROR,\n\t\t\t\t\t<span class=\"hljs-string\">\"Failed to initialize the member node, is empty\"</span>);\n\t}\n\n\t<span class=\"hljs-comment\">// Use the inotify mechanism to monitor file changes and automatically</span>\n\t<span class=\"hljs-comment\">// trigger the reading of cluster.conf</span>\n\t<span class=\"hljs-keyword\">try</span> {\n\t\tWatchFileCenter.registerWatcher(ApplicationUtils.getConfFilePath(), watcher);\n\t}\n\t<span class=\"hljs-keyword\">catch</span> (Throwable e) {\n\t\tLoggers.CLUSTER.error(<span class=\"hljs-string\">\"An exception occurred in the launch file monitor : {}\"</span>, e);\n\t}\n}\n</code></pre>\n<p>The first time you directly read the node list information in the cluster.conf file, then register a directory listener with WatchFileCenter, and automatically trigger <em><strong>readClusterConfFromDisk()</strong></em> to re-read cluster.conf when the cluster.conf file changes file<br /><img src=\"https://cdn.nlark.com/yuque/0/2020/png/333972/1591014354207-49c1e934-2aa5-465a-8a2b-0b09902814f8.png#align=left&amp;display=inline&amp;height=531&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=531&amp;originWidth=1169&amp;size=105696&amp;status=done&amp;style=none&amp;width=1169\" alt=\"image.png\">\n<a name=\"yFTCl\"></a></p>\n<h4>AddressServerMemberLookup</h4>\n<p>This addressing mode is based on an additional web server to manage cluster.conf. Each node periodically requests the content of the cluster.conf file from the web server, and then implements addressing between cluster nodes and expansion and contraction. <br />When you need to expand or shrink the cluster, you only need to modify the cluster.conf file, and then each node will automatically get the latest cluster.conf file content when it requests the address server.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> NacosException </span>{\n\t<span class=\"hljs-keyword\">if</span> (start.compareAndSet(<span class=\"hljs-keyword\">false</span>, <span class=\"hljs-keyword\">true</span>)) {\n\t\t<span class=\"hljs-keyword\">this</span>.maxFailCount = Integer.parseInt(ApplicationUtils.getProperty(<span class=\"hljs-string\">\"maxHealthCheckFailCount\"</span>, <span class=\"hljs-string\">\"12\"</span>));\n\t\tinitAddressSys();\n\t\trun();\n\t}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initAddressSys</span><span class=\"hljs-params\">()</span> </span>{\n\tString envDomainName = System.getenv(<span class=\"hljs-string\">\"address_server_domain\"</span>);\n\t<span class=\"hljs-keyword\">if</span> (StringUtils.isBlank(envDomainName)) {\n\t\tdomainName = System.getProperty(<span class=\"hljs-string\">\"address.server.domain\"</span>, <span class=\"hljs-string\">\"jmenv.tbsite.net\"</span>);\n\t} <span class=\"hljs-keyword\">else</span> {\n\t\tdomainName = envDomainName;\n\t}\n\tString envAddressPort = System.getenv(<span class=\"hljs-string\">\"address_server_port\"</span>);\n\t<span class=\"hljs-keyword\">if</span> (StringUtils.isBlank(envAddressPort)) {\n\t\taddressPort = System.getProperty(<span class=\"hljs-string\">\"address.server.port\"</span>, <span class=\"hljs-string\">\"8080\"</span>);\n\t} <span class=\"hljs-keyword\">else</span> {\n\t\taddressPort = envAddressPort;\n\t}\n\taddressUrl = System.getProperty(<span class=\"hljs-string\">\"address.server.url\"</span>,\n\t\t\t\tApplicationUtils.getContextPath() + <span class=\"hljs-string\">\"/\"</span> + <span class=\"hljs-string\">\"serverlist\"</span>);\n\taddressServerUrl = <span class=\"hljs-string\">\"http://\"</span> + domainName + <span class=\"hljs-string\">\":\"</span> + addressPort + addressUrl;\n\tenvIdUrl = <span class=\"hljs-string\">\"http://\"</span> + domainName + <span class=\"hljs-string\">\":\"</span> + addressPort + <span class=\"hljs-string\">\"/env\"</span>;\n\n\tLoggers.CORE.info(<span class=\"hljs-string\">\"ServerListService address-server port:\"</span> + addressPort);\n\tLoggers.CORE.info(<span class=\"hljs-string\">\"ADDRESS_SERVER_URL:\"</span> + addressServerUrl);\n}\n\n<span class=\"hljs-meta\">@SuppressWarnings</span>(<span class=\"hljs-string\">\"PMD.UndefineMagicConstantRule\"</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> NacosException </span>{\n\t<span class=\"hljs-comment\">// With the address server, you need to perform a synchronous member node pull at startup</span>\n\t<span class=\"hljs-comment\">// Repeat three times, successfully jump out</span>\n\t<span class=\"hljs-keyword\">boolean</span> success = <span class=\"hljs-keyword\">false</span>;\n\tThrowable ex = <span class=\"hljs-keyword\">null</span>;\n\t<span class=\"hljs-keyword\">int</span> maxRetry = ApplicationUtils.getProperty(<span class=\"hljs-string\">\"nacos.core.address-server.retry\"</span>, Integer<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>, 5)</span>;\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; maxRetry; i ++) {\n\t\t<span class=\"hljs-keyword\">try</span> {\n\t\t\tsyncFromAddressUrl();\n\t\t\tsuccess = <span class=\"hljs-keyword\">true</span>;\n\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t} <span class=\"hljs-keyword\">catch</span> (Throwable e) {\n\t\t\tex = e;\n\t\t\tLoggers.CLUSTER.error(<span class=\"hljs-string\">\"[serverlist] exception, error : {}\"</span>, ExceptionUtil.getAllExceptionMsg(ex));\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">if</span> (!success) {\n\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> NacosException(NacosException.SERVER_ERROR, ex);\n\t}\n\n\tGlobalExecutor.scheduleByCommon(<span class=\"hljs-keyword\">new</span> AddressServerSyncTask(), <span class=\"hljs-number\">5_000L</span>);\n}\n</code></pre>\n<p>During initialization, it will take the initiative to synchronize the current cluster member list information with the address server, and if it fails, retry, the maximum number of retries can be controlled by setting <em><strong>nacos.core.address-server.retry</strong></em>, The default is 5 times, and then after success, a scheduled task will be created to synchronize the cluster member node information to the address server<br /><img src=\"https://cdn.nlark.com/yuque/0/2020/png/333972/1591014362972-004f5338-af0d-4d0d-b769-4f3d5118c08a.png#align=left&amp;display=inline&amp;height=846&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=846&amp;originWidth=1149&amp;size=188886&amp;status=done&amp;style=none&amp;width=1149\" alt=\"image.png\">\n<a name=\"sgOTI\"></a></p>\n<h3>How node management and addressing modes are combined</h3>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/333972/1591014400580-39b83aa0-c548-4241-a49e-0d72abda2a95.png#align=left&amp;display=inline&amp;height=715&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=715&amp;originWidth=1189&amp;size=131826&amp;status=done&amp;style=none&amp;width=1189\" alt=\"image.png\"><br />After MemberLookup starts, it will perform addressing tasks according to different addressing modes, will collect cluster node list information, call memberChange, trigger cluster node changes, and then publish node change events\n<a name=\"idHpC\"></a></p>\n<h2>Nacos consensus protocol protocol layer abstraction</h2>\n<p>From the overall architecture of nacos in the future, it can be seen that the consistency protocol layer will be the core module of nacos, and will serve each functional module built on the core module, or the service and core module itself. The consistency protocol needs to choose between availability and consistency because of the existence of partition fault tolerance, so there are two major types of consistency: final consistency and strong consistency. In nacos, both types of consistency protocols are possible. For example, the naming module uses AP and CP for data management of service instances, respectively. For the config module, it will involve the use of CP. At the same time, there are the following functional demand points</p>\n<ol>\n<li>At present, the persistence service uses a variant version of raft, and the business and the raft protocol are coupled. Therefore, it needs to be decoupled and decoupled. At the same time, a standard Java version of Raft is selected for implementation.</li>\n<li>For small and medium-sized users, the configuration is basically not super much. An independent mysql is relatively heavy and requires a light-weight storage solution. It also supports 2.0 not dependent on mysql and 3.0 dependent on mysql configurability</li>\n<li>Due to CP or AP, there are many implementations, how to make a good abstraction of the consistency protocol layer, so that in the future can quickly achieve the specific implementation of the underlying consistency protocol replacement, such as the Raft protocol, the current selection of nacos It is JRaft, it is not excluded that in the future nacos will implement a standard raft protocol or Paxos protocol by itself</li>\n<li>Since there are multiple function modules working independently in Nacos, there can be no influence between each function module. For example, when the A module processes the request too slowly or an exception occurs, it cannot affect the normal operation of the B module, that is, each function module is in use. How to isolate the data processing of each module when using a consistent protocol?</li>\n</ol>\n<p>According to the consensus protocol and the above functional requirements, this time an abstract consensus protocol layer and related interfaces were made\n<a name=\"3w8xM\"></a></p>\n<h3>Consensus agreement abstraction</h3>\n<p><a name=\"p7zRo\"></a></p>\n<h4>ConsistencyProtocol</h4>\n<p>The so-called consistency is the characteristic of whether multiple copies can maintain consistency, and the essence of the copy is data, and the operation of the data is either acquisition or modification. At the same time, the consensus protocol is actually for distributed situations, and this necessarily involves multiple nodes. Therefore, there is a need for a corresponding interface to be able to adjust the coordination protocol of the collaborative work node. What if we want to observe the operation of the consistency agreement? For example, the Raft protocol, we want to know who is the leader in the current cluster, the term of office, and who are the member nodes in the current cluster? Therefore, it is also necessary to provide a consistent protocol metadata acquisition. <br />In summary, the general design of ConsistencyProtcol can come out</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">ConsistencyProtocol</span>&lt;<span class=\"hljs-title\">T</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Config</span>, <span class=\"hljs-title\">P</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">LogProcessor</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">CommandOperations</span> </span>{\n\n    <span class=\"hljs-comment\">/**\n     * Consistency protocol initialization: perform initialization operations based on the incoming Config\n     * 一致性协议初始化，根据 Config 实现类\n     *\n     * <span class=\"hljs-doctag\">@param</span> config {<span class=\"hljs-doctag\">@link</span> Config}\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(T config)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * Add a log handler\n     *\n     * <span class=\"hljs-doctag\">@param</span> processors {<span class=\"hljs-doctag\">@link</span> LogProcessor}\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addLogProcessors</span><span class=\"hljs-params\">(Collection&lt;P&gt; processors)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * Copy of metadata information for this consensus protocol\n     * 该一致性协议的元数据信息\n     *\n     * <span class=\"hljs-doctag\">@return</span> metaData {<span class=\"hljs-doctag\">@link</span> ProtocolMetaData}\n     */</span>\n    <span class=\"hljs-function\">ProtocolMetaData <span class=\"hljs-title\">protocolMetaData</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * Obtain data according to the request\n     *\n     * <span class=\"hljs-doctag\">@param</span> request request\n     * <span class=\"hljs-doctag\">@return</span> data {<span class=\"hljs-doctag\">@link</span> Response}\n     * <span class=\"hljs-doctag\">@throws</span> Exception\n     */</span>\n    <span class=\"hljs-function\">Response <span class=\"hljs-title\">getData</span><span class=\"hljs-params\">(GetRequest request)</span> <span class=\"hljs-keyword\">throws</span> Exception</span>;\n\n    <span class=\"hljs-comment\">/**\n     * Get data asynchronously\n     *\n     * <span class=\"hljs-doctag\">@param</span> request request\n     * <span class=\"hljs-doctag\">@return</span> data {<span class=\"hljs-doctag\">@link</span> CompletableFuture&lt;Response&gt;}\n     */</span>\n    <span class=\"hljs-function\">CompletableFuture&lt;Response&gt; <span class=\"hljs-title\">aGetData</span><span class=\"hljs-params\">(GetRequest request)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * Data operation, returning submission results synchronously\n     * 同步数据提交，在 Datum 中已携带相应的数据操作信息\n     *\n     * <span class=\"hljs-doctag\">@param</span> data {<span class=\"hljs-doctag\">@link</span> Log}\n     * <span class=\"hljs-doctag\">@return</span> submit operation result {<span class=\"hljs-doctag\">@link</span> Response}\n     * <span class=\"hljs-doctag\">@throws</span> Exception\n     */</span>\n    <span class=\"hljs-function\">Response <span class=\"hljs-title\">submit</span><span class=\"hljs-params\">(Log data)</span> <span class=\"hljs-keyword\">throws</span> Exception</span>;\n\n    <span class=\"hljs-comment\">/**\n     * Data submission operation, returning submission results asynchronously\n     * 异步数据提交，在 Datum 中已携带相应的数据操作信息，返回一个Future，自行操作，提交发生的异常会在CompleteFuture中\n     *\n     * <span class=\"hljs-doctag\">@param</span> data {<span class=\"hljs-doctag\">@link</span> Log}\n     * <span class=\"hljs-doctag\">@return</span> {<span class=\"hljs-doctag\">@link</span> CompletableFuture&lt;Response&gt;} submit result\n     * <span class=\"hljs-doctag\">@throws</span> Exception when submit throw Exception\n     */</span>\n    <span class=\"hljs-function\">CompletableFuture&lt;Response&gt; <span class=\"hljs-title\">submitAsync</span><span class=\"hljs-params\">(Log data)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * New member list\n     * 新的成员节点列表，一致性协议自行处理相应的成员节点是加入还是离开\n     *\n     * <span class=\"hljs-doctag\">@param</span> addresses [ip:port, ip:port, ...]\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">memberChange</span><span class=\"hljs-params\">(Set&lt;String&gt; addresses)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * Consistency agreement service shut down\n     * 一致性协议服务关闭\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">shutdown</span><span class=\"hljs-params\">()</span></span>;\n\n}\n</code></pre>\n<p>For the CP protocol, due to the concept of Leader, it is necessary to provide a method for obtaining who is the current Leader of the CP protocol.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">CPProtocol</span>&lt;<span class=\"hljs-title\">C</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Config</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ConsistencyProtocol</span>&lt;<span class=\"hljs-title\">C</span>&gt; </span>{\n\n\t<span class=\"hljs-comment\">/**\n\t * Returns whether this node is a leader node\n\t *\n\t * <span class=\"hljs-doctag\">@param</span> group business module info\n\t * <span class=\"hljs-doctag\">@return</span> is leader\n\t * <span class=\"hljs-doctag\">@throws</span> Exception\n\t */</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isLeader</span><span class=\"hljs-params\">(String group)</span> <span class=\"hljs-keyword\">throws</span> Exception</span>;\n\n}\n</code></pre>\n<p><a name=\"oJFpB\"></a></p>\n<h4>Data operation request submission object：Log、GetRequest</h4>\n<p>As mentioned above, the consistency protocol is actually for data operations. Data operations are basically divided into two categories: data query and data modification, and at the same time, data isolation between different functional modules must be satisfied. Therefore, the data modification operations and data query operations are explained separately here.</p>\n<ol>\n<li>Data modification\n<ol>\n<li>Data modification operation, you must know which functional module this request belongs to</li>\n<li>For data modification operations, you must first know what kind of modification operation this data modification operation is for, so that the function module can perform corresponding logical operations for the real data modification operation</li>\n<li>For data modification operations, you must know what the modified data is, that is, the request body. In order to make the consistency protocol layer more general, here for the data structure of the request body, the byte[] array is selected</li>\n<li>The type of data, because we serialize the real data into a byte[] array, in order to be able to serialize normally, we may also need to record what the type of this data is</li>\n<li>The information summary or identification information of this request</li>\n<li>The additional information for this request is used to expand the data to be transmitted in the future</li>\n</ol>\n</li>\n</ol>\n<p>In summary, it can be concluded that the design of the Log object is as follows</p>\n<pre><code class=\"language-protobuf\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">message</span> <span class=\"hljs-title\">Log</span> </span>{\n\t<span class=\"hljs-comment\">// Function module grouping information</span>\n    <span class=\"hljs-built_in\">string</span> <span class=\"hljs-keyword\">group</span> = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-comment\">// Abstract or logo</span>\n    <span class=\"hljs-built_in\">string</span> key = <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-comment\">// Specific request data</span>\n    <span class=\"hljs-built_in\">bytes</span> data = <span class=\"hljs-number\">3</span>;\n    <span class=\"hljs-comment\">// type of data</span>\n    <span class=\"hljs-built_in\">string</span> type = <span class=\"hljs-number\">4</span>;\n    <span class=\"hljs-comment\">// More specific data manipulation</span>\n    <span class=\"hljs-built_in\">string</span> operation = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-comment\">// extra information</span>\n    map&lt;<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-built_in\">string</span>&gt; extendInfo = <span class=\"hljs-number\">6</span>;\n}\n</code></pre>\n<ol start=\"2\">\n<li>Data query\n<ol>\n<li>For data query operations, you must know which function module initiated the request</li>\n<li>What are the conditions for data query? In order to be compatible with data query operations of various storage structures, here byte[] is used for storage</li>\n<li>The additional information for this request is used to expand the data to be transmitted in the future</li>\n</ol>\n</li>\n</ol>\n<p>In summary, the design of the GetRequest object is as follows</p>\n<pre><code class=\"language-protobuf\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">message</span> <span class=\"hljs-title\">GetRequest</span> </span>{\n\t<span class=\"hljs-comment\">// Function module grouping information</span>\n    <span class=\"hljs-built_in\">string</span> <span class=\"hljs-keyword\">group</span> = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-comment\">// Specific request data</span>\n    <span class=\"hljs-built_in\">bytes</span> data = <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-comment\">// extra information</span>\n    map&lt;<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-built_in\">string</span>&gt; extendInfo = <span class=\"hljs-number\">3</span>;\n}\n</code></pre>\n<p><a name=\"vBig4\"></a></p>\n<h4>Function modules use consistency protocol：LogProcessor</h4>\n<p>After the data operation is submitted through the consistency protocol, each node needs to process the Log or GetRequest object. Therefore, we need to abstract a Log and GetRequest object Processor. Different functional modules implement the processor. ConsistencyProtocol will internally According to the group attributes of Log and GetRequest, the Log and GetRequest objects are routed to a specific Processor. Of course, the Processor also needs to indicate which functional module it belongs to.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LogProcessor</span> </span>{\n\n    <span class=\"hljs-comment\">/**\n     * get data by key\n     *\n     * <span class=\"hljs-doctag\">@param</span> request request {<span class=\"hljs-doctag\">@link</span> GetRequest}\n     * <span class=\"hljs-doctag\">@return</span> target type data\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> Response <span class=\"hljs-title\">onRequest</span><span class=\"hljs-params\">(GetRequest request)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * Process Submitted Log\n     *\n     * <span class=\"hljs-doctag\">@param</span> log {<span class=\"hljs-doctag\">@link</span> Log}\n     * <span class=\"hljs-doctag\">@return</span> {<span class=\"hljs-doctag\">@link</span> boolean}\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> Response <span class=\"hljs-title\">onApply</span><span class=\"hljs-params\">(Log log)</span></span>;\n\n    <span class=\"hljs-comment\">/**\n     * Irremediable errors that need to trigger business price cuts\n     *\n     * <span class=\"hljs-doctag\">@param</span> error {<span class=\"hljs-doctag\">@link</span> Throwable}\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onError</span><span class=\"hljs-params\">(Throwable error)</span> </span>{\n    }\n\n    <span class=\"hljs-comment\">/**\n     * In order for the state machine that handles the transaction to be able to route\n     * the Log to the correct LogProcessor, the LogProcessor needs to have an identity\n     * information\n     *\n     * <span class=\"hljs-doctag\">@return</span> Business unique identification name\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> String <span class=\"hljs-title\">group</span><span class=\"hljs-params\">()</span></span>;\n\n}\n</code></pre>\n<p>For the CP protocol, such as the Raft protocol, there is a snapshot design, so we need to separately extend a method for the CP protocol</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LogProcessor4CP</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">LogProcessor</span> </span>{\n\n    <span class=\"hljs-comment\">/**\n     * Discovery snapshot handler\n     * It is up to LogProcessor to decide which SnapshotOperate should be loaded and saved by itself\n     *\n     * <span class=\"hljs-doctag\">@return</span> {<span class=\"hljs-doctag\">@link</span> List &lt;SnapshotOperate&gt;}\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> List&lt;SnapshotOperation&gt; <span class=\"hljs-title\">loadSnapshotOperate</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> Collections.emptyList();\n    }\n\n}\n</code></pre>\n<p><a name=\"zbsAE\"></a></p>\n<h4>Summary</h4>\n<p>As can be seen from the above points, ConsistencyProtocol is the use interface exposed to the upper layer functional modules. Each ConsistencyProtocol has a backend implemented by a specific consistency protocol. Because Backend cannot be well compatible with nacos existing architecture design, so The additional LogProcessor is designed to solve this problem.<br /><img src=\"https://cdn.nlark.com/yuque/0/2020/png/333972/1591015048030-8a4bff4a-20ed-46dd-a7f7-98655b22946f.png#align=left&amp;display=inline&amp;height=591&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=591&amp;originWidth=886&amp;size=93327&amp;status=done&amp;style=none&amp;width=886\" alt=\"image.png\"><br />同At the time, because the backend inside the consistency protocol layer needs to implement the isolation processing of the data of different business modules, and this piece of logic is implemented by the request object and the group attribute of the LogProcessor<br /><img src=\"https://cdn.nlark.com/yuque/0/2020/png/333972/1591015155835-a897262e-8e57-409c-bf94-d57bf765c80b.png#align=left&amp;display=inline&amp;height=591&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=591&amp;originWidth=910&amp;size=118083&amp;status=done&amp;style=none&amp;width=910\" alt=\"image.png\">\n<a name=\"C1yU6\"></a></p>\n<h3>Consistent protocol layer workflow</h3>\n<p>We can take a look at a sequence diagram, the general workflow of the consistency protocol layer\n<img src=\"https://cdn.nlark.com/yuque/__puml/30b7e270e7aef8bb63136aaffbe5bfbf.svg#lake_card_v2=eyJjb2RlIjoiQHN0YXJ0dW1sXG5cbnBhcnRpY2lwYW50IFwiTWVtYmVyTWFuYWdlclwiIGFzIE5hY29zQ2x1c3RlclxucGFydGljaXBhbnQgXCJCdXNpbmVzc01vZHVsZVwiIGFzIEJpelxucGFydGljaXBhbnQgXCJDb25zaXN0ZW5jeVByb3RvY29sXCIgYXMgUHJvdG9jb2xcbnBhcnRpY2lwYW50IFwiQ0FQQmFja2VuZFwiIGFzIEJhY2tlbmRcbnBhcnRpY2lwYW50IFwiQ29uZmlnXCIgYXMgQ29uZmlnXG5wYXJ0aWNpcGFudCBcIkxvZ1Byb2Nlc3NvclwiIGFzIFByb2Nlc3NvclxucGFydGljaXBhbnQgXCJMb2dcIiBhcyBMb2dcblxuYWN0aXZhdGUgTmFjb3NDbHVzdGVyXG5OYWNvc0NsdXN0ZXIgLT4gTmFjb3NDbHVzdGVyOiBpbml0KCkg5Yid5aeL5YyWTmFjb3Ppm4bnvqRcblxuTmFjb3NDbHVzdGVyIC0-IENvbmZpZzog6I635Y-WQ29uZmln5a-56LGhXG5hY3RpdmF0ZSBDb25maWdcbkNvbmZpZyAtPiBDb25maWc6IOaUtumbhkxvZ1Byb2Nlc3NvcueahOS_oeaBr1xuQ29uZmlnIC0-IE5hY29zQ2x1c3RlclxuZGVhY3RpdmF0ZSBDb25maWdcblxuXG5OYWNvc0NsdXN0ZXIgLT4gUHJvdG9jb2w6IOiOt-WPluaJgOaciUNvbnNpc3RlbmN5UHJvdG9jb2zlrp7njrBcbmFjdGl2YXRlIFByb3RvY29sXG5cbk5hY29zQ2x1c3RlciAtPiBQcm90b2NvbDogaW5pdChDb25maWcpIOaWueazleaJp-ihjFxuXG5kZWFjdGl2YXRlIFByb3RvY29sXG5kZWFjdGl2YXRlIE5hY29zQ2x1c3RlclxuXG5cbkJpeiAtPiBMb2c6IOWIm-W7uuS4gOS4quS6i-WKoeWvueixoVxuYWN0aXZhdGUgQml6XG5hY3RpdmF0ZSBMb2dcblxuXG5Mb2cgLT4gTG9nOiDorr7nva5kYXRhXG5Mb2cgLT4gTG9nOiDorr7nva5rZXlcbkxvZyAtPiBMb2c6IOiuvue9rmNsYXNzTmFtZVxuTG9nIC0-IExvZzog6K6-572uZXh0ZW5kSW5mb1xuTG9nIC0-IEJpelxuZGVhY3RpdmF0ZSBMb2dcblxuQml6IC0-IFByb3RvY29sOiBzdWJtaXQoTG9nKSDosIPnlKjkuIDoh7TmgKfljY_orq7ov5vooYzkuovliqHmj5DkuqRcbmFjdGl2YXRlIFByb3RvY29sXG5cblByb3RvY29sIC0-IEJhY2tlbmQ6IOWGhemDqOS4gOiHtOaAp-WNj-iuruW3peS9nFxuYWN0aXZhdGUgQmFja2VuZFxuXG5CYWNrZW5kIC0-IFByb3RvY29sOiDov5Tlm57lt6XkvZzlpITnkIbnu5PmnpxcbmRlYWN0aXZhdGUgQmFja2VuZFxuXG5Qcm90b2NvbCAtPiBQcm9jZXNzb3I6IOWwhkxvZ-WIhuWPkeWIsOWvueW6lOeahFByb2Nlc3Nvcu-8jOiwg-eUqCBvbkFwcGx5IOaWueazlVxuYWN0aXZhdGUgUHJvdG9jb2xcbmRlYWN0aXZhdGUgUHJvdG9jb2xcblxuUHJvY2Vzc29yIC0-IEJpejog5LqL5Yqh5o-Q5Lqk57uT5p6cXG5cbmRlYWN0aXZhdGUgUHJvY2Vzc29yXG5kZWFjdGl2YXRlIEJpelxuXG5AZW5kdW1sIiwidHlwZSI6InB1bWwiLCJtYXJnaW4iOnRydWUsImlkIjoiNFZpMkwiLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19wdW1sLzMwYjdlMjcwZTdhZWY4YmI2MzEzNmFhZmZiZTViZmJmLnN2ZyIsImNhcmQiOiJkaWFncmFtIn0=\" alt=\"\"><a name=\"xtBNU\"></a></p>\n<h3>The implementation option of CP protocol in Nacos consistency protocol layer——JRaft</h3>\n<p>After the consistency protocol layer is abstracted, the rest is the choice of concrete consistency protocol implementation. Here we have chosen Ant Financial's open source JRaft, so how can we use JRaf as a backend of the CP protocol? The following simple flow chart describes the initialization process when JRaft is used as a Backend of the CP protocol</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/**\n * A concrete implementation of CP protocol: JRaft\n *\n * &lt;pre&gt;\n *                                           ┌──────────────────────┐               \n *                                           │                      │               \n *            ┌──────────────────────┐       │                      ▼               \n *            │   ProtocolManager    │       │        ┌───────────────────────────┐ \n *            └──────────────────────┘       │        │for p in [LogProcessor4CP] │ \n *                        │                  │        └───────────────────────────┘ \n *                        ▼                  │                      │               \n *      ┌──────────────────────────────────┐ │                      ▼               \n *      │    discovery LogProcessor4CP     │ │             ┌─────────────────┐      \n *      └──────────────────────────────────┘ │             │  get p.group()  │      \n *                        │                  │             └─────────────────┘      \n *                        ▼                  │                      │               \n *                 ┌─────────────┐           │                      │               \n *                 │ RaftConfig  │           │                      ▼               \n *                 └─────────────┘           │      ┌──────────────────────────────┐\n *                        │                  │      │  create raft group service   │\n *                        ▼                  │      └──────────────────────────────┘\n *              ┌──────────────────┐         │                                      \n *              │  JRaftProtocol   │         │                                      \n *              └──────────────────┘         │                                      \n *                        │                  │                                      \n *                     init()                │                                      \n *                        │                  │                                      \n *                        ▼                  │                                      \n *               ┌─────────────────┐         │                                      \n *               │   JRaftServer   │         │                                      \n *               └─────────────────┘         │                                      \n *                        │                  │                                      \n *                        │                  │                                      \n *                        ▼                  │                                      \n *             ┌────────────────────┐        │                                      \n *             │JRaftServer.start() │        │                                      \n *             └────────────────────┘        │                                      \n *                        │                  │                                      \n *                        └──────────────────┘                                      \n * &lt;/pre&gt;\n * \n * <span class=\"hljs-doctag\">@author</span> &lt;a href=\"mailto:liaochuntao@live.com\"&gt;liaochuntao&lt;/a&gt;\n */</span>\n</code></pre>\n<p>JRaftProtocol is a concrete implementation of a ConsistencyProtocol when JRaft is used as the backend of the CP protocol. It has a JRaftServer member attribute inside. JRaftServer distributes various API operations of JRaft, such as data operation submission, data query, and member node changes. , Leader node query, etc.</p>\n<p><em><strong>Note: The data generated during JRaft operation is in the ${nacos.home}/data/protocol/raft file directory. Different business modules have different file groupings. If the node crashes or shuts down abnormally, clear the files in the directory and restart the node</strong></em></p>\n<p>Since JRaft implements the concept of raft group, it is possible to use the design of raft group to create a raft group for each function module. Here is part of the code, which shows how to embed LogProcessor in the state machine and create a Raft Group for each LogPrcessor</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">createMultiRaftGroup</span><span class=\"hljs-params\">(Collection&lt;LogProcessor4CP&gt; processors)</span> </span>{\n\t<span class=\"hljs-comment\">// There is no reason why the LogProcessor cannot be processed because of the synchronization</span>\n\t<span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.isStarted) {\n\t\t<span class=\"hljs-keyword\">this</span>.processors.addAll(processors);\n\t\t<span class=\"hljs-keyword\">return</span>;\n\t}\n\n\t<span class=\"hljs-keyword\">final</span> String parentPath = Paths\n\t\t\t\t.get(ApplicationUtils.getNacosHome(), <span class=\"hljs-string\">\"data/protocol/raft\"</span>).toString();\n\n\t<span class=\"hljs-keyword\">for</span> (LogProcessor4CP processor : processors) {\n\t\t<span class=\"hljs-keyword\">final</span> String groupName = processor.group();\n\t\t<span class=\"hljs-keyword\">if</span> (multiRaftGroup.containsKey(groupName)) {\n\t\t\t<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> DuplicateRaftGroupException(groupName);\n\t\t}\n\n\t\t<span class=\"hljs-comment\">// Ensure that each Raft Group has its own configuration and NodeOptions</span>\n\t\tConfiguration configuration = conf.copy();\n\t\tNodeOptions copy = nodeOptions.copy();\n\t\tJRaftUtils.initDirectory(parentPath, groupName, copy);\n\n\t\t<span class=\"hljs-comment\">// Here, the LogProcessor is passed into StateMachine, and when the StateMachine</span>\n\t\t<span class=\"hljs-comment\">// triggers onApply, the onApply of the LogProcessor is actually called</span>\n\t\tNacosStateMachine machine = <span class=\"hljs-keyword\">new</span> NacosStateMachine(<span class=\"hljs-keyword\">this</span>, processor);\n\n\t\tcopy.setFsm(machine);\n\t\tcopy.setInitialConf(configuration);\n\n\t\t<span class=\"hljs-comment\">// Set snapshot interval, default 1800 seconds</span>\n\t\t<span class=\"hljs-keyword\">int</span> doSnapshotInterval = ConvertUtils.toInt(raftConfig\n\t\t\t\t\t\t\t.getVal(RaftSysConstants.RAFT_SNAPSHOT_INTERVAL_SECS),\n\t\t\t\t\tRaftSysConstants.DEFAULT_RAFT_SNAPSHOT_INTERVAL_SECS);\n\n\t\t<span class=\"hljs-comment\">// If the business module does not implement a snapshot processor, cancel the snapshot</span>\n\t\tdoSnapshotInterval = CollectionUtils\n\t\t\t\t\t.isEmpty(processor.loadSnapshotOperate()) ? <span class=\"hljs-number\">0</span> : doSnapshotInterval;\n\n\t\tcopy.setSnapshotIntervalSecs(doSnapshotInterval);\n\t\tLoggers.RAFT.info(<span class=\"hljs-string\">\"create raft group : {}\"</span>, groupName);\n\t\tRaftGroupService raftGroupService = <span class=\"hljs-keyword\">new</span> RaftGroupService(groupName,\n\t\t\t\t\tlocalPeerId, copy, rpcServer, <span class=\"hljs-keyword\">true</span>);\n\n\t\t<span class=\"hljs-comment\">// Because RpcServer has been started before, it is not allowed to start again here</span>\n\t\tNode node = raftGroupService.start(<span class=\"hljs-keyword\">false</span>);\n\t\tmachine.setNode(node);\n\t\tRouteTable.getInstance().updateConfiguration(groupName, configuration);\n\t\tRaftExecutor.executeByCommon(() -&gt; registerSelfToCluster(groupName, localPeerId, configuration));\n\n\t\t<span class=\"hljs-comment\">// Turn on the leader auto refresh for this group</span>\n\t\tRandom random = <span class=\"hljs-keyword\">new</span> Random();\n\t\t<span class=\"hljs-keyword\">long</span> period = nodeOptions.getElectionTimeoutMs() + random.nextInt(<span class=\"hljs-number\">5</span> * <span class=\"hljs-number\">1000</span>);\n\t\tRaftExecutor.scheduleRaftMemberRefreshJob(() -&gt; refreshRouteTable(groupName),\n\t\t\t\t\tnodeOptions.getElectionTimeoutMs(), period, TimeUnit.MILLISECONDS);\n\t\tmultiRaftGroup.put(groupName,\n\t\t\t\t\t<span class=\"hljs-keyword\">new</span> RaftGroupTuple(node, processor, raftGroupService, machine));\n\t}\n}\n</code></pre>\n<p><a name=\"4czvB\"></a></p>\n<h4>Q&amp;A: Why do you want to create multiple raft groups<br /></h4>\n<p>Some people may have doubts. Since the LogProcessor has been designed before, you can use a Raft Group. When the state machine is appl, you can route to different LogProcessors according to the Log group attribute. Each function module creates a Raft group, will it consume a lot of resources? <br />As mentioned before, we hope that the modules that work independently do not affect each other. For example, the A module processing Log may cause the application speed to be slow because of the Block operation, or an exception may occur halfway. For the Raft protocol , When the log apply fails, the state machine will not be able to continue to move forward, because if you continue to move forward, due to the previous step of the apply failure, all subsequent applications may fail, which will cause the data of this node and other nodes Data is never consistent. If we put all the modules that work independently in the same raft group, that is, a state machine, for the data processing request processing, the above-mentioned problems will inevitably occur, and a module will be uncontrollable in the apply log. Factors will affect the normal operation of other modules.\n<a name=\"2GyRw\"></a></p>\n<h3>JRaft operation and maintenance</h3>\n<p>In order to allow users to perform simple operation and maintenance of JRaft, such as leader switching, resetting the current Raft cluster members, triggering a node to perform Snapshot operations, etc., a simple HTTP interface is provided for operation, and the interface has certain Limit, that is, only one operation instruction can be executed at a time</p>\n<p>1、Switch the leader node of a certain Raft Group</p>\n<pre><code class=\"language-java\">POST /nacos/v1/core/ops/raft\n{\n    <span class=\"hljs-string\">\"groupId\"</span>: <span class=\"hljs-string\">\"xxx\"</span>,\n    <span class=\"hljs-string\">\"command\"</span>: <span class=\"hljs-string\">\"transferLeader\"</span>\n    <span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"ip:{raft_port} or ip:{raft_port},ip:{raft_port},ip:{raft_port}\"</span>\n}\n</code></pre>\n<p><a name=\"Fs7VE\"></a>\n2、Reset a Raft Group cluster member</p>\n<pre><code class=\"language-java\">POST /nacos/v1/core/ops/raft\n{\n    <span class=\"hljs-string\">\"groupId\"</span>: <span class=\"hljs-string\">\"xxx\"</span>,\n    <span class=\"hljs-string\">\"command\"</span>: <span class=\"hljs-string\">\"resetRaftCluster\"</span>,\n    <span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"ip:{raft_port},ip:{raft_port},ip:{raft_port},ip:{raft_port}\"</span>\n}\n</code></pre>\n<p>Note that this operation is a high-risk operation. This operation and maintenance command can only be used when the n/2 + 1 node of the Raft cluster fails to meet the requirements of more than half of the vote after the crash. It is used to quickly reorganize the remaining nodes to the Raft cluster to provide external Service, but this operation will greatly cause the loss of data<br /></p>\n<p><a name=\"VfG5T\"></a>\n3、Trigger a Raft Group to perform a snapshot operation</p>\n<pre><code class=\"language-java\">POST /nacos/v1/core/ops/raft\n{\n    <span class=\"hljs-string\">\"groupId\"</span>: <span class=\"hljs-string\">\"xxx\"</span>,\n    <span class=\"hljs-string\">\"command\"</span>: <span class=\"hljs-string\">\"doSnapshot\"</span>,\n    <span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"ip:{raft_port}\"</span>\n}\n</code></pre>\n<p><a name=\"m9LfI\"></a>\n4、Remove a member of a Raft Group</p>\n<pre><code class=\"language-java\">POST /nacos/v1/core/ops/raft\n{\n    <span class=\"hljs-string\">\"groupId\"</span>: <span class=\"hljs-string\">\"xxx\"</span>,\n    <span class=\"hljs-string\">\"command\"</span>: <span class=\"hljs-string\">\"removePeer\"</span>,\n    <span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"ip:{raft_port}\"</span>\n}\n</code></pre>\n<p><a name=\"ev3MW\"></a>\n5、Remove multiple members of a Raft Group in batches</p>\n<pre><code class=\"language-java\">POST /nacos/v1/core/ops/raft\n{\n    <span class=\"hljs-string\">\"groupId\"</span>: <span class=\"hljs-string\">\"xxx\"</span>,\n    <span class=\"hljs-string\">\"command\"</span>: <span class=\"hljs-string\">\"removePeers\"</span>,\n    <span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"ip:{raft_port},ip:{raft_port},ip:{raft_port},...\"</span>\n}\n</code></pre>\n<p><a name=\"GzMuP\"></a></p>\n<h3>JRaft protocol related configuration parameters</h3>\n<pre><code class=\"language-yaml\"><span class=\"hljs-comment\">### Sets the Raft cluster election timeout, default value is 5 second</span>\n<span class=\"hljs-string\">nacos.core.protocol.raft.data.election_timeout_ms=5000</span>\n<span class=\"hljs-comment\">### Sets the amount of time the Raft snapshot will execute periodically, default is 30 minute</span>\n<span class=\"hljs-string\">nacos.core.protocol.raft.data.snapshot_interval_secs=30</span>\n<span class=\"hljs-comment\">### Requested retries, default value is 1</span>\n<span class=\"hljs-string\">nacos.core.protocol.raft.data.request_failoverRetries=1</span>\n<span class=\"hljs-comment\">### raft internal worker threads</span>\n<span class=\"hljs-string\">nacos.core.protocol.raft.data.core_thread_num=8</span>\n<span class=\"hljs-comment\">### Number of threads required for raft business request processing</span>\n<span class=\"hljs-string\">nacos.core.protocol.raft.data.cli_service_thread_num=4</span>\n<span class=\"hljs-comment\">### raft linear read strategy, defaults to index</span>\n<span class=\"hljs-string\">nacos.core.protocol.raft.data.read_index_type=ReadOnlySafe</span>\n<span class=\"hljs-comment\">### rpc request timeout, default 5 seconds</span>\n<span class=\"hljs-string\">nacos.core.protocol.raft.data.rpc_request_timeout_ms=5000</span>\n</code></pre>\n<h4>Linear reading parameter analysis</h4>\n<ol>\n<li><strong>ReadOnlySafe</strong>\n<ol>\n<li>In this linear read mode, every time a Follower makes a read request, it needs to synchronize with the Leader to submit the site information, and the Leader needs to initiate a lightweight RPC request to prove that it is the Leader to more than half of the Follower, which is equivalent to a Follower read, at least 1 + (n/2) + 1 RPC request is required.</li>\n</ol>\n</li>\n<li><strong>ReadOnlyLeaseBased</strong>\n<ol>\n<li>In this linear read mode, each time the Follower makes a read request, the Leader only needs to determine whether its Leader lease has expired. If it does not expire, it can directly reply that the Follower is the Leader, but the mechanism has strict requirements on the machine clock. For clock synchronization, consider using this linear read mode.</li>\n</ol>\n</li>\n</ol>\n<p><a name=\"WiLDa\"></a></p>\n<h2>Nacos embedded distributed ID</h2>\n<p>The distributed ID embedded in nacos is Snakeflower, the dataCenterId defaults to 1, and the value of workerId is calculated as follows</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-string\">InetAddress</span> <span class=\"hljs-string\">address;</span>\n<span class=\"hljs-string\">try</span> <span class=\"hljs-string\">{</span>\n\t<span class=\"hljs-string\">address</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">InetAddress.getLocalHost();</span>\n<span class=\"hljs-string\">}</span> <span class=\"hljs-string\">catch</span> <span class=\"hljs-string\">(final</span> <span class=\"hljs-string\">UnknownHostException</span> <span class=\"hljs-string\">e)</span> <span class=\"hljs-string\">{</span>\n\t<span class=\"hljs-string\">throw</span> <span class=\"hljs-string\">new</span> <span class=\"hljs-string\">IllegalStateException(</span>\n\t\t\t\t\t\t<span class=\"hljs-string\">\"Cannot get LocalHost InetAddress, please check your network!\"</span><span class=\"hljs-string\">);</span>\n<span class=\"hljs-string\">}</span>\n<span class=\"hljs-string\">byte[]</span> <span class=\"hljs-string\">ipAddressByteArray</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">address.getAddress();</span>\n<span class=\"hljs-string\">workerId</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">(((ipAddressByteArray[ipAddressByteArray.length</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-number\">2</span><span class=\"hljs-string\">]</span> <span class=\"hljs-string\">&amp;</span> <span class=\"hljs-string\">0B11)</span>\n\t\t\t\t\t<span class=\"hljs-string\">&lt;&lt;</span> <span class=\"hljs-string\">Byte.SIZE)</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">(ipAddressByteArray[ipAddressByteArray.length</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-number\">1</span><span class=\"hljs-string\">]</span>\n\t\t\t\t\t<span class=\"hljs-string\">&amp;</span> <span class=\"hljs-number\">0xFF</span><span class=\"hljs-string\">));</span>\n</code></pre>\n<p>If you need to manually specify dataCenterId and workerId, add command line parameters in application.properties or startup</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-comment\">### set the dataCenterID manually</span>\n<span class=\"hljs-comment\"># nacos.core.snowflake.data-center=</span>\n<span class=\"hljs-comment\">### set the WorkerID manually</span>\n<span class=\"hljs-comment\"># nacos.core.snowflake.worker-id=</span>\n</code></pre>\n<p><a name=\"ZLp5w\"></a></p>\n<h2>Nacos embedded lightweight Derby-based distributed relational storage</h2>\n<p><a name=\"1B5KV\"></a></p>\n<h3>Background</h3>\n<ol>\n<li>If the number of configuration files is small, the cost of supporting a highly available database cluster in the cluster mode is too large, and it is expected to have a lightweight distributed relational storage to solve</li>\n<li>Some metadata information storage inside nacos, such as user information, namespace information</li>\n<li>Source of ideas:<a href=\"https://github.com/rqlite/rqlite\">https://github.com/rqlite/rqlite</a><br />\n<a name=\"Du2qc\"></a></li>\n</ol>\n<h3>Design ideas</h3>\n<p><a name=\"NzxHa\"></a></p>\n<h4>aims</h4>\n<p>The design goal is to expect nacos to have two data storage modes, one is the current way, the data is stored in an external data source (relational database); the second way is the embedded storage data source (Apache Derby). Users can use the command line parameter configuration to freely use these two data storage modes<br /><img src=\"https://cdn.nlark.com/yuque/0/2020/png/333972/1591015542106-f14d2579-229f-4bfb-a432-e40854e65d6d.png#align=left&amp;display=inline&amp;height=903&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=903&amp;originWidth=1514&amp;size=237497&amp;status=done&amp;style=none&amp;width=1514\" alt=\"image.png\">\n<a name=\"LqUtU\"></a></p>\n<h4>overall</h4>\n<p>Save the SQL context involved in a request operation in order. Then synchronize the SQL context involved in this request through the consensus protocol layer, and then each node parses it and executes it again in a database session in sequence.<br /><img src=\"https://cdn.nlark.com/yuque/0/2020/png/333972/1587204104465-2270480a-de25-4c84-a11b-6edd2de99e66.png#align=left&amp;display=inline&amp;height=814&amp;margin=%5Bobject%20Object%5D&amp;name=%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%281%29.png&amp;originHeight=814&amp;originWidth=1149&amp;size=130886&amp;status=done&amp;style=none&amp;width=1149\" alt=\"未命名文件 (1).png\">\n<a name=\"yxFYn\"></a></p>\n<h4>Related data bearing objects</h4>\n<p>The DML statements of the database are select, insert, update, and delete. According to the nature of SQL statements for data operations, they can be divided into two categories: query and update. The select statement corresponds to data query, and the insert, update, and delete statements correspond to Data modification. At the same time, when performing database operations, in order to avoid SQL injection, PreparedStatement is used, so SQL statements + parameters are required, so two Request objects about database operations can be obtained</p>\n<ol>\n<li>SelectRequest</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SelectRequest</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Serializable</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">long</span> serialVersionUID = <span class=\"hljs-number\">2212052574976898602L</span>;\n    <span class=\"hljs-comment\">// Query category, because currently using JdbcTemplate, query a single, multiple queries, whether to use RowMapper into an object</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">byte</span> queryType;\n    <span class=\"hljs-comment\">// sql语句</span>\n    <span class=\"hljs-comment\">// select * from config_info where</span>\n    <span class=\"hljs-keyword\">private</span> String sql;\n    <span class=\"hljs-keyword\">private</span> Object[] args;\n    <span class=\"hljs-keyword\">private</span> String className;\n}\n</code></pre>\n<ol start=\"2\">\n<li>ModifyRequest</li>\n</ol>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ModifyRequest</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Serializable</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">long</span> serialVersionUID = <span class=\"hljs-number\">4548851816596520564L</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> executeNo;\n    <span class=\"hljs-keyword\">private</span> String sql;\n    <span class=\"hljs-keyword\">private</span> Object[] args;\n}\n</code></pre>\n<p><a name=\"moKl7\"></a></p>\n<h4>Configure publishing</h4>\n<p>The configuration release operation involves three transactions:</p>\n<ol>\n<li>config_info saves configuration information</li>\n<li>config_tags_relation saves the association relationship between configuration and tags</li>\n<li>his_config_info saves a history of configuration operations</li>\n</ol>\n<p>These three transactions are all configured and released under this big transaction. If we say that we perform a Raft protocol submission for each transaction operation, assume that 1, 2 transactions are successfully applied after being submitted through Raft, and the third transaction is in Raft. Apply fails after submission, then for the big transaction released by this configuration, it needs to be rolled back as a whole, otherwise it will violate the atomicity, then it may be necessary to say that the transaction rollback operation is again Raft submitted, then the overall complexity Rise, and directly introduce the management of distributed transactions, so in order to avoid this problem, we integrate the SQL contexts involved in these three transactions into a large SQL context, and submit the Raft protocol to this large SQL context. It ensures that the three sub-transactions successfully solve the atomicity problem in the same database session. At the same time, because the Raft protocol processes the transaction log serially, it is equivalent to adjusting the transaction isolation level of the database to serialization.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addConfigInfo</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> String srcIp,\n\t\t\t<span class=\"hljs-keyword\">final</span> String srcUser, <span class=\"hljs-keyword\">final</span> ConfigInfo configInfo, <span class=\"hljs-keyword\">final</span> Timestamp time,\n\t\t\t<span class=\"hljs-keyword\">final</span> Map&lt;String, Object&gt; configAdvanceInfo, <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">boolean</span> notify)</span> </span>{\n\n\t<span class=\"hljs-keyword\">try</span> {\n\t\t<span class=\"hljs-keyword\">final</span> String tenantTmp = StringUtils.isBlank(configInfo.getTenant()) ?\n\t\t\t\t\tStringUtils.EMPTY :\n\t\t\t\t\tconfigInfo.getTenant();\n\t\tconfigInfo.setTenant(tenantTmp);\n        \n        <span class=\"hljs-comment\">// Obtain the database primary key through the snowflake ID algorithm</span>\n\t\t<span class=\"hljs-keyword\">long</span> configId = idGeneratorManager.nextId(RESOURCE_CONFIG_INFO_ID);\n\t\t<span class=\"hljs-keyword\">long</span> hisId = idGeneratorManager.nextId(RESOURCE_CONFIG_HISTORY_ID);\n\n\t\taddConfigInfoAtomic(configId, srcIp, srcUser, configInfo, time,\n\t\t\t\t\tconfigAdvanceInfo);\n\t\tString configTags = configAdvanceInfo == <span class=\"hljs-keyword\">null</span> ?\n\t\t\t\t\t<span class=\"hljs-keyword\">null</span> :\n\t\t\t\t\t(String) configAdvanceInfo.get(<span class=\"hljs-string\">\"config_tags\"</span>);\n\n\t\taddConfigTagsRelation(configId, configTags, configInfo.getDataId(),\n\t\t\t\t\tconfigInfo.getGroup(), configInfo.getTenant());\n\t\tinsertConfigHistoryAtomic(hisId, configInfo, srcIp, srcUser, time, <span class=\"hljs-string\">\"I\"</span>);\n\t\tEmbeddedStorageContextUtils.onModifyConfigInfo(configInfo, srcIp, time);\n\t\tdatabaseOperate.blockUpdate();\n\t}\n\t<span class=\"hljs-keyword\">finally</span> {\n\t\tEmbeddedStorageContextUtils.cleanAllContext();\n\t}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-title\">addConfigInfoAtomic</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">long</span> id, <span class=\"hljs-keyword\">final</span> String srcIp,\n\t\t\t<span class=\"hljs-keyword\">final</span> String srcUser, <span class=\"hljs-keyword\">final</span> ConfigInfo configInfo, <span class=\"hljs-keyword\">final</span> Timestamp time,\n\t\t\tMap&lt;String, Object&gt; configAdvanceInfo)</span> </span>{\n\t...\n    <span class=\"hljs-comment\">// 参数处理</span>\n    ...\n\t<span class=\"hljs-keyword\">final</span> String sql =\n\t\t\t\t<span class=\"hljs-string\">\"INSERT INTO config_info(id, data_id, group_id, tenant_id, app_name, content, md5, src_ip, src_user, gmt_create,\"</span>\n\t\t\t\t\t\t+ <span class=\"hljs-string\">\"gmt_modified, c_desc, c_use, effect, type, c_schema) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)\"</span>;\n\t<span class=\"hljs-keyword\">final</span> Object[] args = <span class=\"hljs-keyword\">new</span> Object[] { id, configInfo.getDataId(),\n\t\t\t\tconfigInfo.getGroup(), tenantTmp, appNameTmp, configInfo.getContent(),\n\t\t\t\tmd5Tmp, srcIp, srcUser, time, time, desc, use, effect, type, schema, };\n\tSqlContextUtils.addSqlContext(sql, args);\n\t<span class=\"hljs-keyword\">return</span> id;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addConfigTagRelationAtomic</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">long</span> configId, String tagName, String dataId,\n\t\t\tString group, String tenant)</span> </span>{\n\t<span class=\"hljs-keyword\">final</span> String sql =\n\t\t\t\t<span class=\"hljs-string\">\"INSERT INTO config_tags_relation(id,tag_name,tag_type,data_id,group_id,tenant_id) \"</span>\n\t\t\t\t\t\t+ <span class=\"hljs-string\">\"VALUES(?,?,?,?,?,?)\"</span>;\n\t<span class=\"hljs-keyword\">final</span> Object[] args = <span class=\"hljs-keyword\">new</span> Object[] { configId, tagName, <span class=\"hljs-keyword\">null</span>, dataId, group,\n\t\t\t\ttenant };\n\tSqlContextUtils.addSqlContext(sql, args);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insertConfigHistoryAtomic</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">long</span> configHistoryId, ConfigInfo configInfo,\n\t\t\tString srcIp, String srcUser, <span class=\"hljs-keyword\">final</span> Timestamp time, String ops)</span> </span>{\n\t...\n    <span class=\"hljs-comment\">// 参数处理</span>\n    ...\n\t<span class=\"hljs-keyword\">final</span> String sql =\n\t\t\t\t<span class=\"hljs-string\">\"INSERT INTO his_config_info (id,data_id,group_id,tenant_id,app_name,content,md5,\"</span>\n\t\t\t\t\t\t+ <span class=\"hljs-string\">\"src_ip,src_user,gmt_modified,op_type) VALUES(?,?,?,?,?,?,?,?,?,?,?)\"</span>;\n\t<span class=\"hljs-keyword\">final</span> Object[] args = <span class=\"hljs-keyword\">new</span> Object[] { configHistoryId, configInfo.getDataId(),\n\t\t\t\tconfigInfo.getGroup(), tenantTmp, appNameTmp, configInfo.getContent(),\n\t\t\t\tmd5Tmp, srcIp, srcUser, time, ops };\n\n\tSqlContextUtils.addSqlContext(sql, args);\n}\n\n<span class=\"hljs-comment\">/**\n * Temporarily saves all insert, update, and delete statements under\n * a transaction in the order in which they occur\n *\n * <span class=\"hljs-doctag\">@author</span> &lt;a href=\"mailto:liaochuntao@live.com\"&gt;liaochuntao&lt;/a&gt;\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SqlContextUtils</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> ThreadLocal&lt;ArrayList&lt;ModifyRequest&gt;&gt; SQL_CONTEXT =\n            ThreadLocal.withInitial(ArrayList::<span class=\"hljs-keyword\">new</span>);\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">addSqlContext</span><span class=\"hljs-params\">(String sql, Object... args)</span> </span>{\n        ArrayList&lt;ModifyRequest&gt; requests = SQL_CONTEXT.get();\n        ModifyRequest context = <span class=\"hljs-keyword\">new</span> ModifyRequest();\n        context.setExecuteNo(requests.size());\n        context.setSql(sql);\n        context.setArgs(args);\n        requests.add(context);\n        SQL_CONTEXT.set(requests);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;ModifyRequest&gt; <span class=\"hljs-title\">getCurrentSqlContext</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> SQL_CONTEXT.get();\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">cleanCurrentSqlContext</span><span class=\"hljs-params\">()</span> </span>{\n        SQL_CONTEXT.remove();\n    }\n\n}\n</code></pre>\n<p>A more intuitive understanding through a timing diagram\n<img src=\"https://cdn.nlark.com/yuque/__puml/618e8997395fbc74433ac4a60f67b6b4.svg#lake_card_v2=eyJjb2RlIjoiQHN0YXJ0dW1sXG5cbmF1dG9udW1iZXJcblxuYWN0b3IgXCJVc2VyXCIgYXMgVXNlclxuXG5wYXJ0aWNpcGFudCBcIkNvbmZpZ1NlcnZpY2VcIiBhcyBTZXJ2aWNlXG5wYXJ0aWNpcGFudCBcIlBlcnNpc3RlbmNlU2VydmljZVwiIGFzIFJlcG9zaXRvcnlcbnBhcnRpY2lwYW50IFwiRGVyYnlcIiBhcyBEQlxucGFydGljaXBhbnQgXCJTUUxDb250ZXh0VXRpbHNcIiBhcyBTUUxDb250ZXh0XG5wYXJ0aWNpcGFudCBcIkxvZ1Byb2Nlc3NvclwiIGFzIFByb2Nlc3NvclxucGFydGljaXBhbnQgXCJDb25zaXN0ZW5jeVByb3RvY29sXCIgYXMgUHJvdG9jb2xcbnBhcnRpY2lwYW50IFwiTG9nXCIgYXMgTG9nXG5cbmFjdGl2YXRlIFVzZXJcblxuVXNlciAtPiBTZXJ2aWNlOiDlj5HotbfphY3nva7lj5HluIPor7fmsYJcbmFjdGl2YXRlIFNlcnZpY2VcblxuU2VydmljZSAtPiBSZXBvc2l0b3J5OiDphY3nva7lj5HluINcbmFjdGl2YXRlIFJlcG9zaXRvcnlcblxuUmVwb3NpdG9yeSAtPiBTUUxDb250ZXh0OiDmi6bmiKrlvZPliY1TUUzkuIrkuIvmlodcbmFjdGl2YXRlIFNRTENvbnRleHRcblxuUmVwb3NpdG9yeSAtPiBSZXBvc2l0b3J5OiBjb21taXQg5pON5L2cXG5cblNRTENvbnRleHQgLT4gUmVwb3NpdG9yeTog5b2T5YmN6K-35rGC5raJ5Y-K55qE5omA5pyJU1FM5LiK5LiL5paHXG5cbmRlYWN0aXZhdGUgU1FMQ29udGV4dFxuXG5SZXBvc2l0b3J5IC0-IExvZzog5p6E5bu66K-35rGC5L2TXG5cbmFjdGl2YXRlIExvZ1xuZGVhY3RpdmF0ZSBMb2dcblxuUmVwb3NpdG9yeSAtPiBQcm90b2NvbDogc3VibWl0KCkg6L-b6KGM6K-35rGC5o-Q5LqkXG5hY3RpdmF0ZSBQcm90b2NvbFxuZGVhY3RpdmF0ZSBSZXBvc2l0b3J5XG5cblByb3RvY29sIC0-IFByb2Nlc3Nvcjogb25BcHBseSgpIOaWueazle-8jOeKtuaAgeacuuWkjeWItkxvZ1xuYWN0aXZhdGUgUHJvY2Vzc29yXG5cblByb2Nlc3NvciAtPiBSZXBvc2l0b3J5OiDmiafooYzmiYDmnInnmoRTUUzkuIrkuIvmlodcbmFjdGl2YXRlIFJlcG9zaXRvcnlcblxuUmVwb3NpdG9yeSAtPiBEQjog5pWw5o2u6JC95bqTXG5hY3RpdmF0ZSBEQlxuXG5EQiAtPiBSZXBvc2l0b3J5OiDnu5PmnZ_lubbov5Tlm57nu5PmnpxcbmRlYWN0aXZhdGUgREJcblxuUmVwb3NpdG9yeSAtPiBQcm9jZXNzb3I6IOi_lOWbnkxvZ0Z1dHVyZeW5tuiuvue9ruacrOasoeaJp-ihjOeahOe7k-aenFxuZGVhY3RpdmF0ZSBSZXBvc2l0b3J5XG5cblByb2Nlc3NvciAtPiBQcm90b2NvbDog6L-U5ZueTG9nRnV0dXJlXG5kZWFjdGl2YXRlIFByb2Nlc3NvclxuXG5Qcm90b2NvbCAtPiBTZXJ2aWNlOiDmnKzmrKHor7fmsYLnmoTnu5PmnpxcbmRlYWN0aXZhdGUgUHJvdG9jb2xcblxuU2VydmljZSAtPiBVc2VyXG5kZWFjdGl2YXRlIFNlcnZpY2VcbmRlYWN0aXZhdGUgVXNlclxuXG5AZW5kdW1sIiwidHlwZSI6InB1bWwiLCJtYXJnaW4iOnRydWUsImlkIjoiVnQxNzciLCJ1cmwiOiJodHRwczovL2Nkbi5ubGFyay5jb20veXVxdWUvX19wdW1sLzYxOGU4OTk3Mzk1ZmJjNzQ0MzNhYzRhNjBmNjdiNmI0LnN2ZyIsImNhcmQiOiJkaWFncmFtIn0=\" alt=\"\"><a name=\"AAJTE\"></a></p>\n<h3>How to use new features</h3>\n<pre><code class=\"language-bash\">./startup.sh -p embedded\n</code></pre>\n<p>Whether to enable the embedded distributed relational storage activity diagram\n<img src=\"https://cdn.nlark.com/yuque/__puml/1fd656ba3b39fe5de8fea78efdf98dd1.svg#lake_card_v2=eyJjb2RlIjoiQHN0YXJ0dW1sXG5cbigqKSAtLT4gXCJDb25maWcuc3RhcnQoKVwiXG5cbmlmIFwi5Y2V5py65qih5byPXCIgdGhlblxuICAtcmlnaHQtPlt0cnVlXSBcInJldHVybiDpu5jorqTljZXmnLrlrZjlgqjooYzkuLpcIlxuICAtLT4gKCopXG5lbHNlXG4gaWYgXCLlt7LphY3nva7lpJbnva7lrZjlgqhcIiB0aGVuXG4gICAgLS0-W3RydWVdIFwicmV0dXJuIOWklue9ruaVsOaNruWtmOWCqOihjOS4ulwiXG4gICAgLS0-ICgqKVxuIGVsc2VcbiAgICBpZiBcIuW8gOWQr-WGheW1jOWtmOWCqFwiIHRoZW5cbiAgICAgICAgLS0-W3RydWVdIFwicmV0dXJuIOi9u-mHj-WGheW1jOWIhuW4g-W8j-WtmOWCqOihjOS4ulwiXG4gICAgICAgIC0tPiAoKilcbiAgICBlbHNlXG4gICAgICAgIC0-W2ZhbHNlXSBcInJldHVybiDpu5jorqTlpJbnva7mlbDmja7lrZjlgqjooYzkuLpcIlxuICAgICAgICAtLT4gKCopXG5cdFx0ZW5kaWZcbiBlbmRpZlxuZW5kaWZcblxuQGVuZHVtbCIsInR5cGUiOiJwdW1sIiwibWFyZ2luIjp0cnVlLCJpZCI6IkNNN1VDIiwidXJsIjoiaHR0cHM6Ly9jZG4ubmxhcmsuY29tL3l1cXVlL19fcHVtbC8xZmQ2NTZiYTNiMzlmZTVkZThmZWE3OGVmZGY5OGRkMS5zdmciLCJjYXJkIjoiZGlhZ3JhbSJ9\" alt=\"\"><a name=\"9UAXN\"></a></p>\n<h3>New features related operation and maintenance operations</h3>\n<p>Directly query the data stored in each node's derby</p>\n<pre><code class=\"language-java\">GET /nacos/v1/cs/ops/derby?sql=select * from config_info\n\n<span class=\"hljs-keyword\">return</span> List&lt;Map&lt;String, Object&gt;&gt;\n</code></pre>\n<p><a name=\"YcqO2\"></a></p>\n<h3>insufficient</h3>\n<ol>\n<li>Build a distributed data operation synchronization layer on the upper layer of the database, there are restrictions on the operation of the database, such as the first insert operation, then the select operation, and finally the update operation, which is interspersed with query statements in the data modification statement The order of operations is not supported</li>\n<li>Limiting the performance of the database, due to the indirect adjustment of the database transaction isolation level to serialization, the concurrency ability is artificially reduced\n<a name=\"7dul8\"></a></li>\n</ol>\n<h3>Future evolution</h3>\n<p>Apache Derby official will try to realize the synchronous replication operation of BingLog based on Raft, and realize the database synchronization capability from the bottom</p>\n",
  "link": "\\en-us\\blog\\nacos-1.3.0-design.html",
  "meta": {
    "title": "Nacos 1.3.0 new kernel construction process",
    "keywords": "nacos1.3.0,kernel",
    "description": "Nacos 1.3.0 new kernel construction process"
  }
}